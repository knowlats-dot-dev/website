[{"slug":"intro-to-lerna","category":"posts","title":"จัดการ Project ใน Monorepo อย่างง่าย ๆ ด้วย Lerna","description":"มารู้จัก Lerna เครื่องมือที่จะช่วยให้การจัดการ Multi-package Repository ทำได้ง่ายขึ้น","tags":["node.js","javascript","monorepo","tools","lerna"],"body":"\nProject ของ NPM (Node Package Manager) ไม่ว่าจะเป็น Project ที่สร้างขึ้นมาด้วยคำสั่ง `npm init` Project ที่เป็น React, Vue, หรืออะไรที่เป็น JavaScript ที่มีไฟล์ package.json จะถือว่าเป็น 1 Project\n\nโดยปกติแล้ว เรามักจะทำงานกับ Project 1 ตัวต่อกับ 1 Git Repository เท่านั้น แต่ทว่าในโลกความจริง เราสามารถทำงานหลาย Project ต่อ 1 Git Repository ได้ด้วย เราเรียก Repository นั้นว่า **“Multi-package Repository”** หรือ **“Monorepo”**\n\nMonorepo เป็นแนวคิดของการจัดโครงสร้างของการพัฒนา Software อีกรูปแบบหนึ่งที่ให้ Application หรือ Service ต่าง ๆ รวมอยู่ใน Project เดียวกัน มีประโยชน์เด่น ๆ คือ สามารถใช้ Resource และ Code ร่วมกันได้ ลดการเขียน Code ที่ซ้ำซ้อน (Duplicate Code) Refactor โค้ดง่าย (เพราะสามารถแก้ไขได้ในที่เดียว)\n\nแต่ทว่า การทำ Monorepo กับ Project ที่เป็น JavaScript ยังถือว่าเป็นเรื่องที่น่าปวดหัวไม่น้อย เนื่องจากว่า เราต้องจัดการเรื่องของ Dependency (หรือ Package) ที่ใช้ใน Project ย่อยทั้งหมดด้วยตัวเอง (ถ้าคิดไม่ออก ให้ลองนึกภาพ Project ที่ Project ย่อยที่มี package.json เป็นของตัวเองดู จะเห็นว่าเมื่อต้องใช้ `npm install` เราต้องไล่เปิด Project ทำคำสั่งในทุก ๆ Project) อีกทั้งถ้าจะใช้โค้ดจาก Project หนึ่งในอีก Project หนึ่ง เราจะต้องใช้คำสั่ง [NPM link](https://docs.npmjs.com/cli/link.html) ด้วยตนเองอีกเช่นกัน ซึ่งทั้งยุ่งยากและเสียเวลามาก (วิธีการใช้คำสั่ง NPM Link สามารถดูได้ที่[บล็อกนี้](https://medium.com/dailyjs/how-to-use-npm-link-7375b6219557))\n\nในบล็อกนี้ ผู้เขียนจะแนะนำให้รู้จักเครื่องมือหนึ่งที่ช่วยทำให้การทำ Monorepo กับ Project ที่เป็น JavaScript เป็นเรื่องที่ง่ายขึ้น เครื่องมือตัวนี้มีชื่อว่า **“[Lerna](https://github.com/lerna/lerna)”**\n\n## การติดตั้ง Lerna\n\nเราสามารถติดตั้งด้วย NPM แบบ Global ดังคำสั่งด้านล่าง\n\n```\nnpm install -g lerna\n```\n\n## การสร้าง Project ด้วย Lerna\n\nการเริ่มใช้งาน เราต้องสร้างโปรเจคด้วย Lerna ก่อน ดังคำสั่งด้านล่างนี้\n\n```\nmkdir lerna-test-project\ncd lerna-test-project\nlerna init --independent\n```\n\nเมื่อพิมพ์คำสั่งข้างบน ผลลัพธ์จะเป็นดังนี้\n\n```\nlerna notice cli v3.20.2\nlerna info Initializing Git repository\nlerna info Creating package.json\nlerna info Creating lerna.json\nlerna info Creating packages directory\nlerna success Initialized Lerna files\n```\n\nและโฟลเดอร์ชื่อว่า `lerna-test-project` จะถูกสร้างขึ้น ภายในโฟลเดอร์จะมีไฟล์ Configuration ชื่อว่า `lerna.json` พร้อมทั้งโฟลเดอร์ชื่อว่า `packages` ที่จะเป็นที่เก็บ Subproject ต่าง ๆ\n\n```\n.\n├── lerna.json\n├── package.json\n└── packages\n```\n\nเมื่อดูผลลัพธ์ของคำสั่งในตอนแรก จะเห็นได้ว่า Lerna สร้าง Git Repository ให้เราด้วย ถึงตรงนี้เราสามารถพิมพ์ `git commit` เพื่อเพิ่ม Commit แรกได้เลย\n\n## เพิ่ม Subproject แรก\n\nหลังจากสร้าง Project ด้วย Lerna เสร็จแล้ว การสร้าง Project ภายใน Project นี้ (ขอเรียก Subproject เพื่อให้เข้าใจง่าย ๆ) ก็สามารถทำได้ตามถนัด จะสร้างด้วย NPM, `create-react-app`, หรือโปรแกรมอะไรก็ได้\n\nในที่นี้จะขอยกตัวอย่างการสร้าง Subproject ทั้งหมด 3 Project\n\n2 Project เป็น Service ที่พัฒนาด้วย Node.js โดย Service แรกนั้นเป็น REST API ธรรมดา ส่วน Service ที่สองเป็น Server ที่ทำหน้าที่ Serve หน้า Webpage\n\nอีก Project หนึ่งเป็นโค้ดที่ทำหน้าที่เป็น Logging สำหรับ Service ทั้งสอง นี่จะเป็นตัวอย่างของ Project ที่ใช้เป็น Dependency ของ Project อื่นซึ่งจะสร้างในหัวข้อนี้เลย\n\nสร้าง Subproject ชื่อว่า `logger` โดยสร้างเป็น Scoped Project ดังคำสั่งด้านล่าง\n\n```\nmkdir packages/logger\ncd packages/logger\nnpm init --scope=lerna-test --yes\n```\n\n> [NPM Scope](https://docs.npmjs.com/misc/scope) เป็นฟีเจอร์ของ NPM ที่ใช้จัด Project ของเราเป็นกลุ่ม ๆ เมื่อสร้าง NPM จะให้ชื่อ Project ในรูปแบบ `@[ชื่อกลุ่ม]/[ชื่อ Project]` มีประโยชน์อย่างหนึ่งคือสามารถเรียกใช้เป็น Package ให้ Project อื่นได้สะดวก\n\nProject ที่สร้างใหม่จะมี `package.json` เกิดขึ้นดังนี้\n\n```json\n// package.json\n\n{\n  \"name\": \"@lerna-test/logger\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\"\n}\n```\n\nในที่นี้จะใช้ [pinojs/pino](https://github.com/pinojs/pino) ทำ Logging การติดตั้ง Package ใน Subproject จะไม่ใช้ `npm install` แต่จะใช้คำสั่ง `lerna add` แทน\n\n```\nlerna add pino --scope='@lerna-test/logger'\n```\n\nเมื่อดู `package.json` ของ Logger จะเห็นว่ามี Package เพิ่มเข้ามาดังนี้\n\n```json\n// package.json\n\n{\n  \"name\": \"@lerna-test/logger\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \"pino\": \"^6.1.1\" // <--\n  }\n}\n```\n\nจากนั้นสร้างไฟล์ `index.js` เขียนโค้ดที่เราจะใช้ใน Project อื่น และส่งออกผ่าน `module.exports` ดังตัวอย่าง\n\n```javascript\n// packages/logger/index.js\n\nconst pino = require('pino')\n\nconst logger = pino({\n  level: 'debug',\n  formatters: {\n    level(label) {\n      return { level: label }\n    }\n  }\n})\n\nmodule.exports = logger\n```\n\nตอนนี้ Logger ก็พร้อมใช้งานใน Project ต่อไปแล้ว\n\n## สร้าง Subproject ต่อไปเป็น Service\n\nการสร้าง Subproject ไม่จำเป็นต้องสร้างในโฟลเดอร์ packages เสมอไป เราสามารถสร้างในโฟลเดอร์ที่มีชื่อที่สื่อกว่าก็ได้ เช่น services, apps แต่ต้องแก้ไขที่ไฟล์ `lerna.json` เพื่อให้ Lerna เห็น Subproject ที่โฟลเดอร์ดังกล่าวด้วย\n\nในที่นี้จะสร้างโฟลเดอร์ชื่อว่า `services` สำหรับทุก Project ที่เป็น Service ดังนั้นในไฟล์ `lerna.json` ควรแก้ไขโดยเพิ่ม `services/*` ใน packages ดังนี้\n\n```json\n// lerna.json\n{\n  \"packages\": [\n    \"packages/*\",\n    \"services/*\" // <--\n  ],\n  \"version\": \"independent\"\n}\n```\n\nที่โฟลเดอร์ Service ให้สร้าง Service ตัวแรกชื่อ `backend-service`\n\n```\nmkdir -p services/backend-service\ncd services/api-service\nnpm init --scope=lerna-test --yes\n```\n\nและสร้าง service ตัวที่สองชื่อว่า `serve-web-service`\n\n```\ncd .. #ย้อนกลับไปยังโฟลเดอร์ services\nmkdir serve-web-service\ncd serve-web-service\nnpm init --scope=lerna-test --yes\n```\n\nติดตั้ง `express` ให้กับทั้งสอง Service โดยใช้คำสั่ง `lerna add`\n\n```\nlerna add express --scope='@lerna-test/*-service'\n```\n\nเพิ่มไฟล์ `index.js` ให้กับ `backend-service`\n\n```javascript\n// services/backend-service/index.js\n\nconst http = require('http')\nconst express = require('express')\n\nconst app = express()\nconst PORT = 3001\n\napp.get('/hello', (req, res) => {\n  const name = req.query.name\n  if (!name) {\n    res.send('Hello, stranger!')\n    return\n  }\n  if (typeof name !== 'string') {\n    res.status(400).status('Please send name as a string')\n    return\n  }\n  res.send(`Hello, ${name}!`)\n})\n\nconst server = http.createServer(app)\nserver.listen(PORT, () => {\n  console.log(`Server listening on port ${PORT}`)\n})\n```\n\nสำหรับ `web-serve-service` ในที่นี้จะใช้ ejs เป็น Web Template Engine เพิ่มเติม ให้ติดตั้งลงไป\n\n```\nlerna add ejs --scope='@lerna-test/serve-web-service'\n```\n\nเพิ่มไฟล์ `views/index.ejs`\n\n```html\n// services/serve-web-service/views/index.ejs\n\n<html>\n  <head>\n    <title>Lerna Test Webpage</title>\n  </head>\n  <body>\n    <h1><%= title %></h1>\n    <p id=\"greeting\"></p>\n    <p>Welcome to <%= title %></p>\n    <script>\n      const backendUrl = `http://${window.location.hostname}:3001`\n      const name = 'Icegotcha'\n      fetch(`${backendUrl}/hello?name=${name}`)\n        .then((response) => response.text())\n        .then((result) => {\n          document.getElementById('greeting').innerHTML = result\n        })\n        .catch((error) => {\n          document.getElementById(\n            'greeting'\n          ).innerHTML = `Sorry, an error occured: ${error.message}`\n        })\n    </script>\n  </body>\n</html>\n```\n\nและก็เพิ่มไฟล์ `index.js`\n\n```javascript\n// services/serve-web-service/index.ejs\n\nconst http = require('http')\nconst path = require('path')\nconst express = require('express')\n\nconst app = express()\nconst PORT = 3000\n\napp.set('views', path.join(__dirname, 'views'))\napp.set('view engine', 'ejs')\n\napp.get('/', (req, res) => {\n  res.render('index', { title: 'Lerna Test Project' })\n})\n\nconst server = http.createServer(app)\nserver.listen(PORT, () => {\n  console.log(`Server listening on port ${PORT}`)\n})\n```\n\nในหัวข้อที่แล้ว ผู้เขียนได้สร้าง Logger สำหรับใช้ใน Service ทั้งสอง การนำไปใช้จำเป็นต้องติดตั้งลงไปก่อน การติดตั้งก็ใช้คำสั่งเหมือนการติดตั้ง Package ทั่วไป\n\n```\nlerna add @lerna-test/logger --scope='@lerna-test/*-service'\n```\n\nหลังจากใช้คำสั่งนี้ `@lerna-test/logger` ควรอยู่ในรายชื่อ dependencies ในไฟล์ `package.json` ของทั้งสอง Service\n\nต่อจากนี้นำไปใช้ในแต่ละ Service ได้เลย\n\n```javascript\n// services/backend-service/index.js\n\nconst http = require('http')\nconst express = require('express')\nconst logger = require('@lerna-test/logger') // <--\n\nconst app = express()\nconst PORT = 3001\n\napp.get('/hello', (req, res) => {\n  logger.debug('GET /hello is called') // <--\n  const name = req.query.name\n  if (!name) {\n    res.send('Hello, stranger!')\n    return\n  }\n  if (typeof name !== 'string') {\n    res.status(400).status('Please send name as a string')\n    return\n  }\n  res.send(`Hello, ${name}!`)\n})\n\nconst server = http.createServer(app)\nserver.listen(PORT, () => {\n  console.log(`Server listening on port ${PORT}`)\n})\n```\n\n```javascript\n// services/serve-web-service/index.ejs\n\nconst http = require('http')\nconst path = require('path')\nconst express = require('express')\nconst logger = require('@lerna-test/logger') // <--\n\nconst app = express()\nconst PORT = 3000\n\napp.set('views', path.join(__dirname, 'views'))\napp.set('view engine', 'ejs')\n\napp.get('/', (req, res) => {\n  logger.debug('GET / is called') // <--\n  res.render('index', { title: 'Lerna Test Project' })\n})\n\nconst server = http.createServer(app)\nserver.listen(PORT, () => {\n  console.log(`Server listening on port ${PORT}`)\n})\n```\n\nจากขั้นตอนทั้งหมด ตอนนี้ Project `lerna-test-project` มี Subproject ทั้งหมด 3 Project แล้ว นั่นก็คือ\n\n- `@lerna-test/logger`\n\n- `@lerna-test/backend-service` — Web Service ที่มี Route GET /hello ที่ทำหน้าที่ทักทายผู้ใช้ที่ติดต่อเข้ามา\n\n- `@lerna-test/serve-web-service` — Web Service ที่ทำหน้าที่ Render หน้าเว็บทักทายผู้ใช้\n\nจะเห็นได้ว่า แต่ละ Project จะมีโครงสร้างเป็นของตัวเอง แยกหน้าที่การทำงานออกอย่างชัดเจน ที่นี้การเพิ่ม การลบ และการจัดการ Subproject ภายใน Project ก็ไม่เป็นเรื่องยากอีกต่อไป เราสามารถทำงานกับแต่ละ Project เหมือนที่เคยทำกันใน Project ที่ต่อกับ 1 Git repository ได้เลย\n\nสำหรับโครงสร้างของ Project `lerna-test-project` ในตอนนี้ จะเป็นดังรูป\n\n![](/assets/image/post/intro-to-lerna/01.png)\n\nในหัวข้อต่อไป จะอธิบายคำสั่งของ Lerna ที่ควรรู้จัก ได้แก่ `lerna add`, `lerna run`, `lerna exec`, `lerna bootstrap` และ `lerna clean`\n\n## การติดตั้ง Package ให้กับ Project\n\n`lerna add` เป็นคำสั่งที่ใช้ติดตั้ง Package ให้กับ Subproject ที่เรากำหนดไว้ มีความสามารถพิเศษ คือ มันติดตั้ง Package ลงในมากกว่า 1 Project ได้\n\nคำสั่งนี้มีรูปแบบดังนี้\n\n```\nlerna add <package>[@version] [--dev] [--exact] [--peer]\n```\n\nเราสามารถพิมพ์คำสั่ง `lerna add` แล้วตามด้วยชื่อ package เช่น\n\n```\nlerna add axios\n```\n\nผลลัพธ์ที่ได้ คือ Lerna จะติดตั้ง Package axios เวอร์ชันล่าสุดลงในทุก ๆ Project\n\n```json\n// package.json\n\n\"dependencies\": {\n    \"axios\": \"^0.19.2\",\n    // ...\n}\n```\n\nหากต้องการให้ Package ลงในเวอร์ชันล่าสุด แต่ไม่ให้เปลี่ยนแปลงเวอร์ชันได้ในอนาคต ให้ใส่ `--exact` ต่อท้ายด้วย\n\n```\nlerna add axios --exact\n```\n\nผลลัพธ์ที่ได้ ใน `package.json` ส่วน Package นั้นจะไม่มีเครื่องหมายข้างหน้าเวอร์ชัน เช่น เครื่องหมาย ^ (Caret)\n\n```json\n// package.json\n\n\"dependencies\": {\n    \"axios\": \"0.19.2\",\n    // ...\n}\n```\n\n> เครื่องหมาย ^หมายถึง อนุญาตให้ NPM ทำการ Patch Package ในเวอร์ชันใหม่ระดับ Minor\n\nถ้าหากต้องการให้ลงเวอร์ชันตามที่ต้องการ ต้องกำหนดเวอร์ชันหลังชื่อ Package ด้วย\n\n```\nlerna add axios@0.18.1\n```\n\nแล้วจะได้ Package นั้น ๆ ในเวอร์ชันที่กำหนดไว้เลย\n\n```json\n// package.json\n\n\"dependencies\": {\n    \"axios\": \"0.18.1\",\n    // ...\n}\n```\n\nจะลงเป็น Development Dependency หรือ Peer Dependency ก็ทำได้เช่นกัน\n\n```\nlerna add axios --dev\nlerna add axios --peer\n```\n\nมาถึงเรื่องของการเลือก Project ที่จะติดตั้ง\n\nเราสามารถเลือก Project ที่จะติดตั้งลงไปได้โดยเขียน `--scope` ต่อท้ายคำสั่ง แล้วตามด้วยชื่อ Project ดังตัวอย่าง\n\n```\nlerna add axios --scope '@lerna-test/serve-web-service'\n# หรือ\nlerna add axios --scope='@lerna-test/serve-web-service'\n```\n\nLerna จะติดตั้ง `axios` ลงใน Project ที่เลือกไว้ Project เดียว\n\nเราสามารถใช้เครื่องหมาย \\* ประกอบได้เช่นเดียวกัน ยกตัวอย่าง เช่น ในหัวข้อที่แล้ว ผู้เขียนได้ติดตั้ง Package `express` ให้ทั้งสอง Service ด้วยคำสั่งดังนี้\n\n```\nlerna add express --scope='@lerna-test/*-service'\n```\n\nจากคำสั่งนี้แปลความหมายได้ว่า ให้ลง `express` ในทุก Project ที่ชื่อมี `@lerna-test` ตามด้วยตัวอักษรใด ๆ ข้างหน้า `-service`\n\nถ้าจะลงในทุก ๆ Project ยกเว้น Project ใด ๆ ก็ทำได้โดยพิมพ์ --ignore ต่อท้าย ดังตัวอย่าง\n\n```\nlerna add express --ignore '@lerna-test/logger'\n# หรือ\nlerna add express --ignore='@lerna-test/logger'\n```\n\nคำสั่งนี้แปลความหมายได้ว่า ให้ลง `express` ในทุก Project ยกเว้น Project ที่ชื่อ `@lerna-test/logger`\n\n`--ignore` สามารถใช้ร่วมกับ `--scope` ได้ด้วย\n\n```\nlerna add express --scope='@lerna-test/*-service' --ignore='@lerna-test/backend-service'\n```\n\nคำสั่งนี้แปลความหมายได้ว่า ให้ลง `express` ในทุก Project ที่ชื่อมีตัวอักษรใด ๆ อยู่ข้างหน้า `-service` ยกเว้น Project ที่ชื่อ `@lerna-test/backend-service`\n\n## รัน Command ผ่าน Lerna\n\nนอกจากการติดตั้ง Package แล้ว Lerna ยังสามารถช่วยทำคำสั่งในทุก Project ที่เลือกพร้อมกันได้ ผ่านคำสั่ง `lerna exec` และ `lerna run`\n\nก่อนอื่น ผู้เขียนขอเพิ่มคำสั่ง npm start ให้กับทั้งสอง Service เพื่อนำไปใช้เป็นตัวอย่างคำสั่งที่ใช้ใน `lerna exec`, `lerna run` โดยแก้ไขไฟล์ `package.json` ของทั้งสอง Service ให้มีเนื้อหาเพิ่มเติมดังนี้\n\n```json\n\"scripts\": {\n    ...\n    \"start\": \"node index.js\",\n    ...\n},\n```\n\nคำสั่ง `npm start` จะเป็นคำสั่งเปิดการทำงานของแต่ละ Service\n\nมาเริ่มกันที่ `lerna exec`\n\n`lerna exec` มีรูปแบบคำสั่งดังนี้\n\n```\nlerna exec -- <command> [..args]\n```\n\nด้วยคำสั่งนี้ ทำให้เราสามารถรันคำสั่งอะไรก็ได้ในทุก Project เช่น Linux Command, NPM Script เป็นต้น\n\nลบโฟลเดอร์ `node_modules`\n\n```\nlerna exec -- rm -rf ./node_modules\n```\n\nรัน NPM Script\n\n```\nlerna exec -- npm start\n```\n\nเราสามารถเลือก Project ผ่าน option `--scope` และ `--ignore` เช่นเดียวกับ lerna add ในคำสั่งนี้ต้องพิมพ์หลังคำว่า exec ดังตัวอย่าง\n\n```\n lerna exec --scope '@lerna-test/*-service' -- npm start\n```\n\nปกติแล้ว คำสั่งนี้จะรันคำสั่งแบบขนานกัน (Parallel) โดยทำงานเป็น Thread จำนวนสอดคล้องกับ core ของ CPU ที่อยู่ในเครื่อง และถ้ามี Logging ออกมาทาง Console หรือ Command Line จะแยกไม่ออกว่าเป็นของ Subproject ไหน\n\nถ้าต้องการให้มีชื่อ Project กำกับ Logging สามารถทำได้ด้วยการเพิ่ม\n`--parallel` ต่อท้ายคำว่า exec เช่น\n\n```\nlerna exec --parallel --scope '@lerna-test/*-service' -- npm start\n```\n\nข้อแตกต่างคำสั่งที่ไม่มี `--parallel` และคำสั่งที่มี `--parallel` จะเห็นได้จาก Console ดังตัวอย่าง\n\n![](/assets/image/post/intro-to-lerna/02.png)\n\n_รูปเปรียบเทียบผลลัพธ์ของคำสั่งที่ไม่มี `-- parallel` และมี `--parallel`_\n\n`--parallel` จะรันคำสั่งในทุก Project ที่เลือกทันที โดยไม่สนใจเรื่องข้อจำกัดของ CPU หากต้องการให้ Lerna รันโดยคำนึงถึงเรื่องข้อจำกัดของ CPU แต่ยังต้องการให้แยก Logging ให้เปลี่ยนจาก `--parallel` เป็น `--stream` แทน\n\n```\nlerna exec --stream --scope '@lerna-test/*-service' -- npm start\n```\n\nนอกจาก `lerna exec` แล้ว เราสามารถใช้คำสั่ง `lerna run` เพื่อรันคำสั่งที่เป็น NPM script แทนได้ จากตัวอย่าง ถ้าจะรัน `npm start` ด้วยคำสั่ง `lerna run` แทน `lerna exec` สามารถเขียนคำสั่งได้เป็นดังนี้\n\n```\nlerna run start\nlerna run start --scope '@lerna-test/*-service'\nlerna run start --parallel --scope '@lerna-test/*-service'\n```\n\n> คำสั่ง `lerna run` ทำงานเหมือน `lerna exec` แต่สามารถรันได้เฉพาะ NPM Script เท่านั้น\n\n## การติดตั้ง Package ทั้งหมด และการลบ Package ใน Lerna\n\nเรายังคงสามารถใช้ `npm install` ใน Project ที่ใช้ Lerna ได้อยู่ตราบเท่าที่ไม่มีการใช้ Subproject เป็น Package ให้ Subproject อื่น\n\nแต่ถ้าใช้ไปแล้ว การใช้คำสั่ง `npm install` จะทำไม่สำเร็จ เพราะว่า NPM หา Package บางตัวใน NPM Registry ไม่พบ ซึ่งมันก็คือ Subproject ที่อยู่ภายใน Project ที่เราทำงานอยู่นั่นเอง\n\n![](/assets/image/post/intro-to-lerna/03.png)\n\nทางแก้ปัญหานี้คือ ใช้คำสั่ง `lerna bootstrap` แทน\n\n`lerna bootstrap` เป็นคำสั่งพื้นฐานที่เราต้องใช้ นอกจากคำสั่งนี้จะช่วยติดตั้ง Package แทน `npm install` แล้ว สิ่งสำคัญที่มันทำถัดมาก็คือ สร้าง Symlink เชื่อมกับซอร์สโค้ดของ Subproject ที่เป็น Dependency ของ Subproject อื่น\n\nโดยปกติแล้วโฟลเดอร์ `node_modules` จะทำหน้าที่เก็บซอร์สโค้ดของ Dependency ที่เราติดตั้ง ซอร์สโค้ดทั้งหมดจะมาจากภายนอก ยกเว้น Dependency ที่เป็น Subproject ซึ่งมีซอร์สโค้ดอยู่ภายใน Project หลักแล้ว พวกนี้จะเก็บเป็นไฟล์ Symlink แทน ดังรูปตัวอย่างด้านล่าง ลักษณะจะเป็นเหมือนไฟล์ Shortcut ที่จะนำเราไปสู่ซอร์สโค้ดของ Subproject นั้น เพราะฉะนั้น หากมี Subproject ใดใช้ Dependency นั้น ก็เท่ากับว่า Subproject นั้นกำลังเข้าถึงซอร์สโค้ดของ Dependency ผ่านไฟล์ Symlink อยู่นั่นเอง\n\n```\n./services/backend-service/node_modules\n├── @lerna-test\n│   └── logger -> ../../../../packages/logger\n├── other-package-1\n│   ├── index.js\n│   ├── LICENSE\n│   ├── package.json\n│   └── README.md\n├── other-package-2\n│   ├── index.js\n│   ├── LICENSE\n│   ├── package.json\n│   └── README.md\n├── other-packages...\n| ...\n```\n\nสำหรับการลบ Package เราจะใช้คำสั่ง `npm uninstall` หรือ `npm remove` ไม่ได้เพราะว่าคำสั่งนี้มีการสแกนไฟล์ `package.json` เพื่อเช็คซอร์สโค้ดแต่ละ Package ด้วย ก่อนที่จะลบ Package ที่เลือกออกไป และมันจะทำไม่สำเร็จเพราะหา Package บางตัวไม่เจอเช่นเดียวกับตอนใช้คำสั่ง `npm install`\n\nทางเดียวที่จะลบ Package ได้ ก็คือ เราต้องไปลบชื่อ Package ที่เราต้องการลบในไฟล์ `package.json` เอง ลบโฟลเดอร์ `node_module` โดยใช้คำสั่ง lerna clean จากนั้นก็ใช้คำสั่ง `lerna bootstrap`\n\n`lerna clean` เป็นอีกคำสั่งหนึ่งของ Lerna ใช้ลบโฟลเดอร์ `node_module` สามารถเลือกลบเฉพาะใน `Subproject` ที่ต้องการโดยใช้ `--scope` และ `--ignore` มันดีกว่าคำสั่ง `lerna exec --rm -rf ./node_modules` ตรงที่มีให้เรายืนยันก่อนว่าจะลบจริงหรือไม่ และมี Log ให้เราดูว่ามันลบที่ Subproject ไหนบ้าง ดังตัวอย่าง\n\n```\ninfo cli using local version of lerna\nlerna notice cli v3.20.2\nlerna info versioning independent\nlerna info Removing the following directories:\nlerna info clean packages/logger/node_modules\nlerna info clean services/a/node_modules\nlerna info clean services/backend-service/node_modules\nlerna info clean services/serve-web-service/node_modules\n? Proceed? Yes\nlerna info clean removing /home/icegotchaf/lerna-test-project/packages/logger/node_modules\nlerna info clean removing /home/icegotchaf/lerna-test-project/services/a/node_modules\nlerna info clean removing /home/icegotchaf/lerna-test-project/services/backend-service/node_modules\nlerna info clean removing /home/icegotchaf/lerna-test-project/services/serve-web-service/node_modules\nlerna success clean finished\n```\n\n## เกี่ยวกับ Package.json ที่เป็นของ Project หลัก\n\nที่ผ่านมา เรายุ่งกับไฟล์ `package.json` ที่เป็นของแต่ละ Subproject เท่านั้น ในหัวข้อนี้ ผู้เขียนจะขอพูดถึงไฟล์ `Package.json\\_ ที่เป็นของ Project หลัก (Root ของ Project) สักเล็กน้อย\n\nไฟล์ `package.json` นี้เราสามารถที่จะจัดการตามปกติได้เลย เช่น การติดตั้ง Package โดยใช้ `npm install` (Package ที่ติดตั้งตรงนี้จะสามารถใช้งานกับทุก Subproject) การลบ Package โดยใช้ `npm uninstall` หรือการเพิ่ม NPM Script ใด ๆ หรือแม้แต่การเพิ่มให้รันด้วย npm แทน lerna ก็ทำได้เช่นกัน ดังตัวอย่าง\n\n```json\n{\n  \"name\": \"root\",\n  \"private\": true,\n  \"devDependencies\": {\n    \"lerna\": \"^3.20.2\"\n  },\n  \"scripts\": {\n    \"start:all\": \"lerna run start --scope='@lerna-test/*-service' --parallel\"\n  }\n}\n```\n\nจากตัวอย่าง ผู้เขียนได้เพิ่ม `start:all` ในส่วนของ scripts ทำให้สามารถรัน Service ทั้งสองด้วยคำสั่ง `npm run start:all`\n\nแต่ถ้าใช้ Yarn workspace ร่วมด้วยแล้ว คำสั่งที่ใช้จัดการจะเปลี่ยนไปเล็กน้อย ดังที่จะได้เห็นในหัวข้อถัดไป\n\n## เสริม: ใช้ Yarn Workspace ร่วมกับ Lerna เพื่อชีวิตที่ดีกว่า\n\n![](/assets/image/post/intro-to-lerna/yarn.jpg)\n\n_Photo by [Les Triconautes](https://unsplash.com/@triconautes) on [Unsplash](https://unsplash.com)_\n\nหากเริ่มใช้ Lerna ใน Project แล้ว ผู้เขียนขอแนะนำให้ใช้ Yarn Workspace ร่วมด้วย เพราะมันช่วยอำนวยความสะดวกให้เรามากกว่าการใช้ Lerna ล้วน ๆ ตั้งแต่ต้นจนจบกระบวนการของการพัฒนาเลยทีเดียว\n\nWorkspace คือ Feature หนึ่งของ Yarn โปรแกรมที่ช่วยจัดการกับ Package เช่นเดียวกับ NPM\n\nFeature นี้จะให้โฟลเดอร์ `node_modules` จาก Root ของ Project เป็นศูนย์รวมของซอร์สโค้ดของ Dependency ของ Subproject ทั้งหมด นั่นหมายความว่า แต่ละ Subproject ไม่จำเป็นต้องมีโฟลเดอร์ `node_modules` เป็นของตัวเองอีกต่อไป ลดการมีซอร์สโค้ดซ้ำกรณีที่มีหลาย Subproject ใช้ Dependency ตัวเดียวกัน ซึ่งช่วยลดการใช้พื้นที่ฮาร์ดดิสก์ลงไปมากทีเดียว\n\nนอกจากช่วยประหยัดพื้นที่ฮาร์ดดิสก์แล้ว การแชร์ `node_modules` ยังช่วยอำนวยสะดวกให้หลายอย่าง เราสามารถจัดการ Dependency ทั้งการเพิ่ม Package และการลบ Package ได้ด้วยคำสั่งของ Yarn คำสั่งเดียว\n\nก่อนเริ่มใช้งาน Yarn Workspace เราต้องติดตั้ง Yarn ลงในเครื่องก่อน ซึ่งการติดตั้ง สามารถเข้าไปดูได้[ที่นี่](https://classic.yarnpkg.com/en/docs/install)\n\nต่อจากนี้ ให้เราเข้าไปที่ Project ของเรา ทำการแก้ package.json โดยเพิ่ม Property \"workspaces\" และกำหนดที่อยู่ของ Subproject ทั้งหมดในรูปแบบดังนี้\n\n```json\n\"workspaces\": {\n    \"packages\": [\n    \"packages/*\",\n    \"services/*\"\n    ]\n},\n```\n\nไฟล์ `package.json` ตอนนี้ควรเป็นดังนี้\n\n```json\n{\n  \"name\": \"root\",\n  \"private\": true,\n  \"devDependencies\": {\n    \"lerna\": \"^3.20.2\"\n  },\n  \"workspaces\": {\n    \"packages\": [\"packages/*\", \"services/*\"]\n  },\n  \"scripts\": {\n    \"start:all\": \"lerna run start --scope='@lerna-test/*-service' --parallel\"\n  }\n}\n```\n\nแก้ไขไฟล์ `lerna.json` เพิ่มข้อมูลทั้งสองตัวนี้ลงไป\n\n```json\n// lerna.json\n\n{\n    ...\n    \"npmClient\": \"yarn\",\n    \"useWorkspaces\": true,\n    ...\n}\n```\n\n`npmClient` — ให้ Lerna สามารถใช้ตัวจัดการ Package ตามที่เราต้องการได้ หากเปลี่ยนเป็น Yarn หมายความว่า Lerna จะใช้ Yarn แทน NPM ทำคำสั่งต่าง ๆ\n\n`useWorkspaces` — ใส่ค่าเป็น true เพื่อเปิดใช้ Yarn Workspace\n\nเป็นอันเสร็จ เราได้เปิดใช้ Yarn Workspace ใน Project แล้ว\n\nการเปลี่ยนแปลงนี้จะมีผลอย่างไรบ้าง?\n\n- **ลดจำนวนไฟล์ `package-lock.json`** — นอกจากโฟลเดอร์ `node_modules` แล้ว Workspace ยังช่วยลดจำนวนไฟล์ `package-lock.json` ด้วย ไฟล์นี้เป็นไฟล์ที่เก็บเวอร์ชัน ข้อมูลและที่อยู่ของซอร์สโค้ดใน NPM Server ของ Dependency ต่าง ๆ ซึ่งปกติแล้วมันต้องอยู่คู่กับ `package.json` แต่ Workspace จะทำให้ไฟล์นี้ไม่จำเป็นอีก มันจะเปลี่ยนไปเก็บไว้ในไฟล์ `yarn.lock` ที่อยู่ใน Root ของ Project แทน ซึ่งช่วยลดความขัดแย้งของ Dependency ได้มาก\n\n- **ความเร็วในการทำคำสั่ง** — Yarn ทำคำสั่งเร็วและมีประสิทธิภาพกว่า NPM\n\n- **การทำคำสั่งของ Lerna** — หากลองรัน `lerna add` หรือ `lerna run` จะเห็นว่า Lerna ใช้ Yarn ทำงานแทน NPM\n\n- **การทำคำสั่งของเรา** — เราต้องใช้ Yarn แทน NPM ทำคำสั่งต่าง ๆ เพื่อให้ได้ประสิทธิภาพสูงสุด\n\n- **การเพิ่ม Package** — เราสามารถใช้ `yarn add <package-name>` ในการเพิ่ม Package ลงใน Subproject หนึ่งได้ อีกทั้งถ้าต้องการติดตั้ง Package ทั้งหมดใหม่ (ที่มักจะทำกันตอน Git clone ใหม่ ๆ) เราสามารถใช้คำสั่ง yarn หรือ yarn install คำสั่งเดียวได้ มันจะไม่เกิด Error `E404` ที่เกิดจากการค้นหา Package ใน NPM Server (ยกเว้นถ้าจะติดตั้ง Subproject เป็น Dependency จะไม่สามารถทำได้ ต้องใช้ `lerna add`)\n\n- **การลบ Package** — เราสามารถใช้ `yarn remove <package-name>` ในการลบ Package ได้ด้วย ซึ่งสามารถลบได้อย่างราบรื่นเช่นเดียวกับตอนเพิ่ม Package **แต่ก็ยังมีข้อจำกัดอยู่ก็คือ **เราไม่สามารถใช้คำสั่งนี้ลบ Package ในหลาย Subproject พร้อมกันได้\\*\\* หากต้องการลบพร้อมกัน ให้ลบชื่อ Package ที่เราต้องการลบในไฟล์ package.json เอง จากนั้นใช้คำสั่ง lerna clean และ lerna bootstrap แทน\n\n- **การติดตั้ง Common Package** — หากเราจะติดตั้ง Package ที่ Root ของ Project เราต้องใช้คำสั่ง `yarn add <package-name> -W` เพื่อให้ Yarn ยอมรับการติดตั้ง Package ที่ Root ของ Project (-W มีชื่อ Option เต็ม ๆ คือ--ignore-workspace-root-check)\n\n## สรุปและทิ้งท้าย\n\nเราได้รู้จักกับ Lerna ที่เป็นเครื่องมือช่วยจัดการ Project ภายใน Project ไปแล้ว ในบล็อกนี้ได้แสดงวิธีการเริ่มต้น Project ใหม่ และการสร้าง Subproject ด้วย Lerna รวมไปถึงการใช้คำสั่งของ Lerna เพื่อติดตั้ง Package และรันคำสั่งต่าง ๆ ซึ่งคำสั่งที่ยกมามีดังนี้\n\n- `lerna add` — ช่วยติดตั้ง Dependency ใน Subproject ที่เลือกไว้\n\n- `lerna exec` — ช่วยรันคำสั่ง Command line ใน Subproject ที่เลือกไว้\n\n- `lerna run` — ช่วยรัน NPM Script ใน Subproject ที่เลือกไว้\n\n- `lerna bootstrap` — ช่วยติดตั้ง Dependency ต่าง ๆ ที่อยู่ในไฟล์ package.json ของ Subproject และช่วยสร้างไฟล์ Symlink เชื่อมกับซอร์สโค้ดของ Subproject ที่เป็น Dependency ของ Subproject อื่น\n\n- `lerna clean` — ช่วยลบโฟลเดอร์ node_modules ใน Subproject ที่เลือกไว้\n\nความสามารถของ Lerna ยังไม่หมดเพียงเท่านี้นะคะ หากคุณผู้อ่านสนใจต้องการเรียนรู้เพิ่มเติมจากนี้ ก็สามารถเข้าไปดูที่ [Github ของ Lerna](https://github.com/lerna/lerna) ในนี้จะมีรายการคำสั่งและวิธีการใช้อย่างละเอียด\n\nขอขอบคุณผู้อ่านทุกคนที่อ่านบล็อกนี้จนจบด้วยนะคะ กด 👏 เพื่อเป็นกำลังใจให้ให้ผู้เขียนได้ ถ้ามีคำแนะนำหรือคำติชมอะไร สามารถ Comment ได้เลยนะคะ\n\nพบกันใหม่ในบล็อกหน้า สวัสดีค่ะ\n\n---\n\n_This article was originally published at [Medium.com](https://medium.com/@icegotchafantasoxy/introduction-to-lerna-tool-for-monorepos-7a3d6fe4d65c)_\n"},{"slug":"openapi-101","category":"posts","title":"OpenAPI 101 — มารู้จัก OpenAPI ผู้ช่วยสร้าง REST API กันเถอะ","description":"บทความนี้ ผู้อ่านจะได้ทำความรู้จักกับ OpenAPI มาตรฐานการอธิบายลักษณะ REST API ที่จะเปลี่ยนแปลงการพัฒนา REST API ให้ดีขึ้นกว่าเดิม","tags":["openapi","api"],"body":"\nตอนนี้ Software ไม่ใช่โปรแกรมที่มีชุดคำสั่งรวมกันเป็นก้อนเดียวก้อนใหญ่อีกต่อไป แต่ประกอบด้วย Service ตัวเล็ก ๆ หลายตัวเชื่อมต่อกันเรียกว่า Microservices ซึ่งอาจจะเป็นของเราเอง หรือเป็นของคนอื่น (Third Party) ก็ได้ การเชื่อมต่อกันของ Service ทุกตัวจะต้องทำผ่าน Protocol สักตัวหนึ่ง ในปัจจุบัน Service จำนวนมากจะเป็น [**REST API**](https://restfulapi.net/) เนื่องจาก REST API นั้นมีวิธีการรับส่งข้อมูลที่ทำได้ง่ายและสะดวกที่สุด\n\nแต่การพัฒนา Service ที่เป็น REST API นั้นกลับเป็นเรื่องน่าปวดหัว ทั้งนี้เนื่องจากการเชื่อมต่อกันไปมาของ Service เป็นการเพิ่มความซับซ้อนให้กับระบบ เราจะต้องมีข้อมูลเกี่ยวกับการเชื่อมต่อของแต่ละ Service ที่ทำให้ทุกคนที่เกี่ยวข้อง เช่น นักออกแบบระบบ นักพัฒนาระบบ นักทดสอบระบบ Stakeholders ลูกค้า คนภายนอกคนอื่น ๆ ที่เข้ามาใช้งานระบบของเรา หรือแม้แต่เราในอนาคตเข้าใจ เพื่อให้การพัฒนาเป็นไปอย่างราบรื่น หากมีการแก้ไข Service เราต้องตามไปแก้ข้อมูลอยู่เสมอ แต่บางครั้งอาจมีเกิดเหตุที่ทำให้เราไม่ได้ทำข้อมูลและเอกสารต่าง ๆ เก็บไว้ หรือทำแล้วแต่ข้อมูลอาจตกหล่นไปไม่ครบถ้วน ทำให้ความยุ่งยากและปัญหาตามมามากมาย\n\nในบางครั้งเราต้องพัฒนา SDK และ Software Development Kit เพื่อทำให้คนอื่นเข้าใช้งาน REST API ของเราง่ายที่สุด แน่นอนว่าทำส่วนนี้เป็นการเพิ่ม Cost ยิ่งต้องทำ SDK หลายภาษาโปรแกรมก็ยิ่งเพิ่ม Cost เข้าไปอีก อาจจะเพิ่มอย่างไม่จำเป็นด้วย อย่างเช่น นั่งแปลงโค้ดจากภาษาหนึ่งไปเป็นอีกภาษาหนึ่ง เป็นต้น\n\nในบทความนี้ จะกล่าวถึงตัวที่ช่วยลดปัญหาที่ว่ามานี้ให้กับเรา ตัวนี้มีชื่อว่า OpenAPI\n\n# OpenAPI คืออะไร?\n\nOpenAPI ที่พูดถึงกันมักหมายถึง **OpenAPI Specification** เป็นมาตรฐานในการอธิบาย REST API ตัวหนึ่ง ที่ให้ทั้งคนและเครื่องคอมพิวเตอร์อ่านได้ เมื่อเราเขียน API Specification ตามมาตรฐานนี้ เราสามารถใช้มันเป็นตัวกลางในการสื่อสารกับคนในทีม เช่น Developer, Tester และลูกค้า รวมถึงใช้เป็นตัวช่วยสร้าง พัฒนา ปรับปรุง REST API ให้ตรงกับสิ่งที่เราเขียนไว้เสมอ\n\n# ประวัติของ OpenAPI\n\nOpenAPI Specification มีชื่อเดิมคือ **Swagger Specification** ถูกพัฒนาในปี 2011 โดย **Tony Tam** เป็น Co-founder ของบริษัททำระบบดิกชันนารีออนไลน์ [Wordnik](https://www.wordnik.com) เขาได้พัฒนาพร้อมกับ Swagger UI ซึ่งเป็นโปรแกรมช่วยสร้างเอกสารจาก Specification ตัวนี้ เพื่อลดปัญหาความยุ่งยากในการสร้างเอกสารและ SDK (Software Development Kit) ระหว่างการพัฒนา Wordnik อยู่นั่นเอง\n\nหลังจากทำเสร็จและปล่อยออกมาเป็น Open-source ก็มีการใช้มากขึ้นอย่างกว้างขวาง เพราะในตอนนั้น Swagger เป็นโปรเจคแรกที่ออกแบบกลไกให้เครื่องคอมพิวเตอร์สามารถประมวลผล Specification ของ REST API ได้\n\nต่อมาในปี 2015 [SmartBear Software](https://smartbear.com/) ก็ได้เข้ามาให้ความสนใจและสนับสนุนโครงการ Swagger ก่อนที่จะร่วมมือกับ Linux Foundation ตั้งบริษัทแยกขึ้นมาเพื่อพัฒนา Swagger Specification โดยเฉพาะ ชื่อว่า [OpenAPI Initiative](https://www.openapis.org/) (OAI)\n\nSwagger Specification ก็ได้ถูกตั้งชื่อใหม่เป็น OpenAPI Specification ในปี 2016 และก็มีเวอร์ชัน 3.0.0 ออกมาในปี 2017 ตั้งแต่ตอนนั้น OpenAPI Specification เวอร์ชัน 3 ก็ได้รับพัฒนาเรื่อย ๆ จนถึงปัจจุบัน\n\n# โครงสร้างของ OpenAPI Specification\n\nในปัจจุบัน OpenAPI Specification มี 2 เวอร์ชันใหญ่ ๆ คือ Swagger 2.0 และ OpenAPI 3.x\n\n**Swagger 2.0** เป็นเวอร์ชันดั้งเดิมของ OpenAPI ถูกสร้างตั้งแต่ปี 2014 และนิยมใช้กันจนถึงปัจจุบัน เวอร์ชัน 2.0 มีโครงสร้างสรุปได้ดังภาพนี้\n\n![](/assets/image/post/intro-to-openapi/01.png)\n\n*ภาพแสดงโครงสร้างของ Swagger 2.0*\n\n**OpenAPI 3.x** เป็นเวอร์ชันที่เกิดขึ้นมาในปี 2017 โครงสร้างในเวอร์ชันนี้จะแตกต่างจาก Swagger 2.0 อย่างสิ้นเชิง ถ้าเรานำ 2 เวอร์ชันนี้เปรียบเทียบกัน จะเห็นว่า OpenAPI 3.x มีโครงสร้างที่เรียบง่ายกว่า เพราะมีการรวมข้อมูลบางส่วนเป็นข้อมูลก้อนใหญ่ก้อนเดียว ทำให้ Specification มีความยืดหยุ่น พัฒนาปรับปรุงได้ง่าย และทำความเข้าใจได้ง่ายกว่า รองรับการทำงานกับ API ทั้งในปัจจุบันและอนาคต\n\n![](/assets/image/post/intro-to-openapi/02.png)\n\n*ภาพแสดงโครงสร้างของ OpenAPI 3.0*\n\nในหัวข้อนี้จะเจาะลึกโครงสร้างของ OpenAPI เวอร์ชัน 3 กัน จากภาพโครงสร้างจะเห็นได้ว่า เราสามารถแบ่งเป็น 7 ส่วนดังนี้\n\n## 1. openapi\n\nส่วนนี้แสดงเวอร์ชันของ OpenAPI ที่ใช้เขียน Specification ชุดนี้ จะต้องเขียนในรูปแบบ [Sematic versioning](https://en.wikipedia.org/wiki/Software_versioning) ที่เป็นเลขเวอร์ชันมีตัวเลขสามส่วน เวอร์ชันของ OpenAPI ที่ใช้เขียนได้นั้นสามารถดูได้ที่[หน้า Release ของ OpenAPI](https://github.com/OAI/OpenAPI-Specification/releases)\n\n```\nopenapi: 3.0.0\n```\n\n## 2. info\n\nส่วนนี้แสดงข้อมูลทั่วไปของ REST API\n\n```yaml\ninfo:\n   description: >-\n     This is a sample server Petstore server. For this sample, you can use the api key\n     `special-key` to test the authorization filters.\n   version: 1.0.0\n   title: OpenAPI Petstore\n   license:\n     name: Apache-2.0\n     url: 'https://www.apache.org/licenses/LICENSE-2.0.html'\n   termsOfService: http://example.com/terms/\n   contact:\n     name: API Support\n     url: http://www.example.com/support\n     email: support@example.com\n```\n\n*   **title** — ชื่อเรียกของ REST API\n*   **description** — รายละเอียดเกี่ยวกับ REST API สามารถเขียนหลายบรรทัดได้\n*   **version** — เวอร์ชันของ REST API ปัจจุบัน คนละอย่างกับส่วน openapi ตรงนี้สามารถเขียนเป็น Sematic versioning, String ลงท้ายด้วย `-alpha` หรือ `-beta` (`1.0-beta`), หรือวันที่ (`2020-05-21`)\n*   **license** — ชื่อของ License ที่ใช้และลิงก์ที่สามารถเข้าไปดูรายละเอียดของ License นั้น\n*   **contact** — ข้อมูลด้านการความช่วยเหลือหรือ Support ข้อมูลของ REST API\n*   **termsOfService** — ลิงก์ URL ที่ไปยังหน้า Terms of Service\n\n## 3. servers\n\nส่วนนี้แสดงข้อมูลเกี่ยวกับ Server ที่ตั้งของ API หรือ Base path\n\n```yaml\nservers:\n  - url: http://api.example.com/v1\n    description: Main server\n  - url: http://staging-api.example.com\n    description: Internal staging server for testing\n```\n\n## 4. paths\n\nส่วนนี้คือส่วนใหญ่ที่สุด เป็นส่วนที่แสดง Endpoint (หรือ Path) ต่าง ๆ ของ API รวมถึง Operation ที่สามารถใช้กับ Endpoint นั้นได ้(ในที่นี้ก็คือ HTTP verb ต่าง ๆ เช่น Get, Post, Put, Delete)\n\n```yaml\npaths:\n  '/pet/{petId}':\n    get:\n      tags:\n        - pet\n      summary: Find pet by ID\n      description: Returns a single pet\n      operationId: getPetById\n      parameters:\n        - name: petId\n          in: path\n          description: ID of pet to return\n          required: true\n          schema:\n            type: integer\n            format: int64\n      responses:\n        '200':\n          description: successful operation\n          content:\n            application/xml:\n              schema:\n                $ref: '#/components/schemas/Pet'\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Pet'\n        '400':\n          description: Invalid ID supplied\n        '404':\n          description: Pet not found\n      security:\n        - api_key: []\n    post:\n      tags:\n        - pet\n      summary: Updates a pet in the store with form data\n      description: ''\n      operationId: updatePetWithForm\n      parameters:\n        - name: petId\n          in: path\n          description: ID of pet that needs to be updated\n          required: true\n          schema:\n            type: integer\n            format: int64\n      responses:\n        '405':\n          description: Invalid input\n      security:\n        - petstore_auth:\n            - 'write:pets'\n            - 'read:pets'\n      requestBody:\n        content:\n          application/x-www-form-urlencoded:\n            schema:\n              type: object\n              properties:\n                name:\n                  description: Updated name of the pet\n                  type: string\n                status:\n                  description: Updated status of the pet\n                  type: string\n    delete:\n      tags:\n        - pet\n      summary: Deletes a pet\n      description: ''\n      operationId: deletePet\n      parameters:\n        - name: api_key\n          in: header\n          required: false\n          schema:\n            type: string\n        - name: petId\n          in: path\n          description: Pet id to delete\n          required: true\n          schema:\n            type: integer\n            format: int64\n      responses:\n        '400':\n          description: Invalid pet value\n      security:\n        - petstore_auth:\n            - 'write:pets'\n            - 'read:pets'\n```\n\nจากตัวอย่าง เป็นการแสดงการเขียน Path หนึ่งตัวภายในส่วน `paths` นี้ชื่อ `pet/{petId}` ซึ่งมี Operation อยู่สามตัวคือ `get, post` และ `delete` แต่ละ Operation ก็มีข้อมูลรายละเอียดอยู่ภายในอีก ซึ่งมีรายละเอียดดังนี้\n\n*   **tags** — รายชื่อกลุ่มที่ Operation จะอยู่ สามารถมีได้หลาย Tag\n*   **summary** — ใช้แนะนำว่า Operation นี้คืออะไร? ทำงานอะไร?\n*   **description** — บอกรายละเอียดเพิ่มเติมเกี่ยวกับ Operation นี้ เช่น การทำงาน การส่งค่าเข้ามา เป็นต้น สามารถพิมพ์ได้หลายบรรทัดได้\n*   **operationId** — Identity ของ Operation นี้ ตรงส่วนนี้ต้องมีค่าไม่ซ้ำกันระหว่าง Operation ด้วยกัน มักจะตั้งชื่อตรงกับชื่อฟังก์ชันที่ใช้ใน Code เพื่อบอกให้รู้ว่า Operation ทำงานตามฟังก์ชันใด\n*   **security** — ลักษณะของ Authentication ที่ต้องใช้ใน Operation นี้\n\n```yaml\nsecurity:\n   - petstore_auth:\n         - 'write:pets'\n         - 'read:pets'\n```\n\nหากเราต้องการใช้ Authentication เช่น OAuth2, Basic Token ใน Operation หนึ่ง เราสามารถเพิ่มส่วน security พร้อมสิทธิ์เข้าถึงที่เราต้องการให้ผู้ใช้ต้องมีก่อนเข้าใช้งาน ดังตัวอย่างด้านบนนี้ แต่ก่อนที่เราจะเพิ่มที่นี่ เราต้องกำหนดชนิดและกระบวนการ (Flow) ของ Authentication ใน securitySchemes ซึ่งอยู่ภายในส่วนที่เรียกว่า `components` (มีพูดถึงในส่วนสุดท้าย) ดังตัวอย่างด้านล่าง\n\n```yaml\ncomponents:\n    securitySchemes:\n        petstore_auth:\n           type: oauth2\n           flows:\n             implicit:\n                authorizationUrl: 'http://petstore.com/api/oauth'\n                scopes:\n                   'write:pets': modify pets in your account\n                    'read:pets': read your pets\n```\n\n*   **requestBody** —นี้มีไว้สำหรับกำหนดรายละเอียดของข้อมูลที่ต้องส่งมาให้ Operation ทาง Request Body ซึ่งมักจะใช้ใน Operation ประเภท POST, PUT, PATCH ในส่วนนี้เราต้องกำหนด Media Types และโครงสร้างของข้อมูลที่รับในแต่ละ Media Type ใน `content` ซึ่ง Media Type กำหนดได้โดยอิงตาม[รายการนี้](https://www.iana.org/assignments/media-types/media-types.xhtml) (เช่น application/x-www-form-urlencoded, application/json, multipart/form-data เป็นต้น) ส่วนโครงสร้างข้อมูลหรือ `schema` นั้น เราสามารถสร้างขึ้นมาโดยตรง หรือจะใช้ `$ref` อ้างอิงถึง Schema ที่เรากำหนดไว้ในส่วน `component`\n\n> ส่วนของ Schema นั้น เป็นส่วนที่สำคัญมากในการเขียน Specification ใช้กำหนดโครงสร้างข้อมูลทั้งใน Request Body, Parameter, Response, Header และภายในตัว Schema ด้วยกันเอง สามารถดูการเขียนได้ที่[ลิงก์นี้](https://swagger.io/docs/specification/data-models/)\n\nตัวอย่างการกำหนด Schema โดยตรง\n\n```yaml\nrequestBody:\n    content:\n       application/x-www-form-urlencoded:\n          schema:\n             type: object\n             properties:\n                name:\n                  description: Updated name of the pet\n                  type: string\n                status:\n                  description: Updated status of the pet\n                  type: string\n```\n\nตัวอย่างการกำหนด Schema โดยใช้ `$ref`\n\n```yaml\nrequestBody:\n    description: Pet object that needs to be added to the store\n    required: true\n    content:\n         application/json:\n           schema:\n             $ref: '#/components/schemas/Pet'\n         application/xml:\n           schema:\n             $ref: '#/components/schemas/Pet'\n```\n\n*   **parameters** — มีไว้สำหรับกำหนดรายละเอียดของข้อมูลที่ต้องส่งมาให้ Operation ทาง Query, Path, Header, และ Cookie\n\n```yaml\n\nparameters:\n    - name: petId\n      in: path\n      description: ID of pet to return\n      required: true\n      schema:\n         type: integer\n         format: int64\n```\n\n*   **responses** — มีไว้กำหนดรายละเอียดของข้อมูลที่ Operation จะส่งกลับเมื่อทำงานเสร็จแล้ว เริ่มต้นด้วยเขียน HTTP Status Code และลักษณะโครงสร้างข้อมูลหรือ Response Body ให้ในแต่ละ HTTP Status Code ซึ่ง Response Body จะเขียนเป็น Schema เช่นเดียวกับ Request Body แต่จะไม่เขียนเลยก็ได้ หากไม่เขียนจะอ่านได้หลายความหมาย คือ Operation จะไม่ส่ง Response Body มาให้ หรือ Operation ส่งเป็นข้อความตามที่เขียนใน description\n\n```yaml\nresponses:\n   '200':\n     description: successful operation\n     content:\n       application/xml:\n         schema:\n           $ref: '#/components/schemas/Pet'\n       application/json:\n         schema:\n           $ref: '#/components/schemas/Pet'\n    '400':\n      description: Invalid ID supplied\n    '404':\n      description: Pet not found\n    '405':\n      description: Validation exception\n```\n\n## 5. tags\n\nเป็นส่วนที่รวบรวมชื่อที่ใช้จัดกลุ่มของ Operation เครื่องมือบางตัวสามารถจัดการแบ่งกลุ่มให้เราเห็นอย่างชัดเจน หากเรานำ Specification ไปใช้ในเครื่องมือนั้น เช่น Swagger UI\n\nSwagger UI ใช้ส่วนนี้ในการแสดง Operation เป็นกลุ่มอย่างชัดเจน ดังรูปด้านล่าง โดยการจัดกลุ่มมีผลเมื่อมี Operation ที่มีข้อมูล `tags` อยู่เท่านั้น หาก Operation ใดไม่มี `tags` ก็จะอยู่กลุ่ม default แทน\n\n```yaml\ntags:\n  - name: pet\n    description: Everything about your Pets\n  - name: store\n    description: Access to Petstore orders\n  - name: user\n    description: Operations about user\n```\n\n![](/assets/image/post/intro-to-openapi/03.png)\n\n*รูปแสดงการจัดกลุ่มโดยใช้ Tags ของ Swagger UI*\n\n## 6. externalDocs\n\nส่วนนี้เป็นส่วนที่แสดง URL ของเว็บไซต์ที่มีข้อมูลนอกเหนือจาก Specification\n\n```yaml\nexternalDocs:\n  description: Find out more about Swagger\n  url: 'http://swagger.io'\n```\n\n## 7. components\n\nเป็นส่วนที่รวบรวมโครงสร้างต่าง ๆ เพื่อให้เราสามารถนำเฉพาะชื่อไปใช้ในส่วนอื่น ๆ ใน Specification ผ่าน `$ref` โดยโครงสร้างที่เขียนในส่วนนี้ได้นั้น มีดังต่อไปนี้\n\n*   Schema Object (เก็บผ่าน `schemas`)\n*   Request Body (เก็บผ่าน `requestBodies`)\n*   Response Body (เก็บผ่าน `responses`)\n*   Parameter (เก็บผ่าน `parameters`)\n*   Header Object (เก็บผ่าน `headers`)\n*   Example Object (เก็บผ่าน `examples`)\n*   Authentication (เก็บผ่าน `securitySchemes` )\n\n```yaml\ncomponents:\n  #-------------------------------\n  # Reusable schemas (data models)\n  #-------------------------------\n  schemas:\n    User:             # Can be referenced as '#/components/schemas/User'\n      type: object\n      properties:\n        id:\n          type: integer\n          format: int64\n        name:\n          type: string\n    Error:            # Can be referenced as '#/components/schemas/Error'\n      type: object\n      properties:\n        code:\n          type: integer\n        message:\n          type: string\n  #-------------------------------\n  # Reusable operation parameters\n  #-------------------------------\n  parameters:\n    offsetParam:      # Can be referenced via '#/components/parameters/offsetParam'\n      name: offset\n      in: query\n      description: Number of items to skip before returning the results.\n      required: false\n      schema:\n        type: integer\n        format: int32\n        minimum: 0\n        default: 0\n    limitParam:       # Can be referenced as '#/components/parameters/limitParam'\n      name: limit\n      in: query\n      description: Maximum number of items to return.\n      required: false\n      schema:\n        type: integer\n        format: int32\n        minimum: 1\n        maximum: 100\n        default: 20\n  #-------------------------------\n  # Reusable responses\n  #-------------------------------\n  responses:\n    404NotFound:       # Can be referenced as '#/components/responses/404NotFound'\n      description: The specified resource was not found.\n    ImageResponse:     # Can be referenced as '#/components/responses/ImageResponse'\n      description: An image.\n      content:\n        image/*:\n          schema:\n            type: string\n            format: binary\n    GenericError:      # Can be referenced as '#/components/responses/GenericError'\n      description: An error occurred.\n      content:\n        application/json:\n          schema:\n            $ref: '#/components/schemas/Error'\n```\n\nจากรายละเอียดข้างต้น สรุปได้ว่า ข้อมูลที่เราสามารถเขียนใน OpenAPI Specification จะมีดังนี้\n\n*   ข้อมูลเบื้องต้นเกี่ยวกับ REST API ของเรา เช่น เวอร์ชันปัจจุบัน ช่องทางการติดต่อ (Support) ลิขสิทธิ์ (License) เงื่อนไขการใช้งาน (Term of use) ข้อมูลของ Server ที่ใช้ในแต่ละ Environment เป็นต้น\n*   วิธีการพิสูจน์ตัวตน (Authentication) ในการเข้าใช้งาน API\n*   Endpoint ต่าง ๆ และ Operation ของแต่ละ Endpoint (HTTP Verb ต่าง ๆ เช่น GET, POST, PUT, DELETE เป็นต้น)\n*   ข้อมูลนำเข้า (Path Parameters, Queries, Request Bodies) และข้อมูลส่งออก (Response) ของแต่ละ Operation\n\n ยังมีรายละเอียดอยู่เยอะมาก หากต้องการรู้วิธีการเขียนเพิ่มเติม ก็สามารถเข้าไปที่ลิงก์เหล่านี้ได้ค่ะ\n\n- [Swagger Specification Documentation](https://swagger.io/docs/specification/about/)\n\n- [Full OpenAPI Specification](http://spec.openapis.org/oas/v3.0.3)\n\nและสามารถดูตัวอย่าง openAPI Specification แบบเต็ม ๆ ได้ที่[ลิงก์นี้](https://github.com/OpenAPITools/openapi-generator/blob/master/modules/openapi-generator/src/test/resources/3_0/petstore.yaml)\n\n# การเขียน OpenAPI Specification\n\nเราสามารถเริ่มเขียน OpenAPI Specification ตั้งแต่ตอนที่ยังไม่สร้าง REST API ซึ่งจะทำให้เราสามารถสร้าง API ตามแนวคิด **API Design-First Approach** วิธีนี้จะช่วยให้ทั้งคนในทีม และลูกค้าเห็นภาพของ API ที่สมบูรณ์ก่อนลงมือเขียนโค้ด เมื่อเขียนเสร็จแล้ว เราสามารถใช้ Specification สร้าง API ปลอม (Mock API) และเอกสาร รวมไปถึงโค้ดบางส่วนอัตโนมัติ ทำให้คนในทีมทำงานสะดวกขึ้น สามารถทำงานเป็น Parallel ได้ ซึ่งส่งผลให้การสร้าง API เป็นไปอย่างรวดเร็วและมีประสิทธิภาพมากยิ่งขึ้น\n\n![](/assets/image/post/intro-to-openapi/04.png)\n\n*ภาพกระบวนการพัฒนาโปรแกรมแบบ API Design-first Approach*\n\nเราสามารถเขียน OpenAPI Specification ใน Text Editor ทั่วไปที่เราใช้งานอยู่ หรือจะใช้ **Swagger Editor** ก็ได้ เป็น Text Editor ตัวหนึ่งที่ถูกสร้างขึ้นเพื่อทำ OpenAPI Specification โดยเฉพาะ โปรแกรมนี้จะแบ่งหน้าต่างออกเป็นสองส่วน ส่วนด้านซ้ายคือส่วนที่ให้เราเขียน OpenAPI Specification กับอีกส่วนหนึ่งคือ ส่วนด้านขวาเป็น Live Preview เอกสารจากที่เราเขียนในขณะนั้น\n\n![](/assets/image/post/intro-to-openapi/05.png)\n\n*รูปแสดง Visual Studio Code ที่ลง Extension ชื่อว่า [OpenAPI (Swagger) Editor](https://marketplace.visualstudio.com/items?itemName=42Crunch.vscode-openapi) และ [Swagger Viewer](https://marketplace.visualstudio.com/items?itemName=Arjun.swagger-viewer) ไว้ ซึ่งช่วยให้เราสามารถจัดการกับข้อมูลส่วนต่าง ๆ และดูเอกสารที่สร้างจาก Specification ตามลำดับ เมื่อเราเปิดทำงานกับไฟล์ OpenAPI Specification ไฟล์หนึ่ง*\n\n![](/assets/image/post/intro-to-openapi/06.png)\n\n*รูปแสดงหน้าตาของ OpenAPI Editor ชื่อว่า Swagger Editor*\n\nหากไม่ต้องการสร้าง Specification ด้วยการเขียนด้วยมือ เราก็ใช้เครื่องมือพวก GUI Editor สร้างขึ้นได้เช่นกัน เครื่องมือประเภทนี้ทำให้เราสามารถสร้าง Specification โดยไม่จำเป็นต้องเรียนรู้วิธีการเขียนมากนัก บางตัวก็มีเครื่องมือเล็ก ๆ ที่ช่วยอำนวยความสะดวกมาให้อีกด้วย อย่างเช่น ตัวช่วยตรวจความถูกต้องของ Specification, ตัวช่วยสร้าง Mock API, ตัวช่วยสร้างเอกสาร เป็นต้น\n\nเครื่องมือที่นิยมใช้กันมีดังนี้\n\n*   [Stoplight Studio](https://stoplight.io/studio/) (App-based, Free)\n*   [Apicurio Studio](https://www.apicur.io/studio/) (Web-based, Free)\n*   [Apitive Studio](https://www.apitive.com/studio/) (Web-based, Free)\n*   [Represen Studio](https://www.reprezen.com/) (App-Based, Free Trial)\n\nอีกวิธีหนึ่งคือ เขียนอธิบายเป็นคอมเมนต์หรือฟังก์ชันในโค้ดโปรแกรม และให้เครื่องมือประเภท **Automate API documentation** ช่วยสแกนและสร้าง Specification จากโค้ดที่เขียนไว้เลย เครื่องมือประเภทนี้ถูกสร้างขึ้นสำหรับใช้กับภาษาโปรแกรมเพียงภาษาเดียว ยกตัวอย่างเช่น\n\n*   [tsoa](https://github.com/lukeautry/tsoa) — ใช้ใน Node.js REST API ที่เขียนด้วย TypeScript\n*   [Springdoc](https://springdoc.org/) — ใช้ใน Spring Application (REST API ภาษา Java, หากต้องการใช้ สามารถดูวิธีการใช้ที่[ลิงก์นี้](https://www.baeldung.com/spring-rest-openapi-documentation))\n\nเครื่องมือประเภทนี้เหมาะสำหรับโปรเจคที่มี REST API ตัวจริงมาแล้วแต่ยังไม่มีเอกสารใด ๆ มันช่วยสร้างความสะดวกให้กับเรา เราไม่ต้องเสียเวลาสร้างเอกสารขึ้นเอง ช่วยลดปัญหาเอกสารและ REST API ทำงานไม่ตรงกัน อีกทั้งยังช่วยให้นักพัฒนารู้ข้อมูลเกี่ยวกับ API Endpoint ที่ทำงานอยู่ทันที เนื่องจากข้อมูลเกี่ยวกับ API Endpoint ส่วนใหญ่จะเป็นคอมเมนต์อยู่ใกล้กับโค้ดของ API Endpoint แต่ละตัว แต่ก็มีข้อเสียอยู่เช่นเดียวกัน คือ มันจะเพิ่มขั้นตอนและอาจเพิ่มเวลาการเริ่มทำงานของ REST API ด้วย และทำให้โค้ดดูเยอะและรกหากไม่มีการจัด Format ของโค้ดที่ดีพอ\n\n# การใช้ OpenAPI กับ REST API\n\nในปัจจุบันมีเครื่องมือที่ทำงานกับ API Specification ที่เขียนตามมาตรฐานนี้อยู่มากมาย ส่วนใหญ่จะช่วยสร้างเอกสาร และช่วยเพิ่มความสะดวกในการพัฒนา ปรับปรุง และทดสอบ REST API ทำให้เรามั่นใจได้ว่า REST API ที่สร้างนั้นจะตรงกับ API Specification ที่เราเขียนไว้ ในหัวข้อนี้จะยกตัวอย่างเครื่องมือบางตัวที่ทำงานกับ API Specification ในหมวดหมู่ดังต่อไปนี้\n\n*   เครื่องมือช่วยสร้าง Source code\n*   เครื่องมือช่วยสร้างเอกสาร\n*   เครื่องมือช่วยสร้าง Mock API Server\n*   เครื่องมือช่วย Validate API\n\n## เครื่องมือช่วยสร้าง Source code\n\n![](/assets/image/post/intro-to-openapi/07.png)\n\n*รูปแสดงหน้าเว็บของ OpenAPI Generator — [openapi-generator.tech](https://openapi-generator.tech/)*\n\nเครื่องมือประเภทนี้สามารถสร้าง Source code ของ Application และเอกสารตามภาษาที่เราเลือกให้ได้ ภายในตัวเครื่องมือจะมีฟังก์ชันต่าง ๆ เตรียมไว้ให้เราใช้งาน เรียกว่า Generator มีอยู่ 3 ประเภทใหญ่ ๆ คือ\n\n*   **Client Generator** — ใช้สร้าง Application ที่มีการติดต่อกับ REST API อยู่บ่อยครั้ง เช่นพวก Frontend, หรือพวก SDK (Software Development Kit), โปรแกรม CLI (Command-line Interface) ภายใน Source code ที่สร้างขึ้นจะมีฟังก์ชันติดต่อกับ REST API ติดมาให้\n*   **Server (Stub) Generator** — ใช้สร้าง Application ที่เป็น REST API เมื่อสร้างออกมา จะมีฟังก์ชันสร้าง Server, ฟังก์ชันที่เรียกใช้ Middleware ที่จำเป็น เช่น ฟังก์ชันกำหนด Header, CORS เป็นต้น และฟังก์ชันที่เป็น Controller ของแต่ละ API Endpoint เตรียมไว้ให้ สามารถใช้เป็น API ปลอม (เรียกว่า Server Stub หรือ Mock API) ให้ Client ลองติดต่อ หรือจะใช้เป็นตัวเริ่มต้นนำไปสู่การสร้าง REST API ที่สมบูรณ์ก็ได้\n*   **Document Generator** — ใช้สร้างเอกสารในรูปแบบต่าง ๆ มักจะมีในรูปแบบ HTML ให้ใช้\n\nเครื่องมือที่นิยมใช้กันจะมีอยู่ 2 ตัว คือ [Swagger Codegen](https://github.com/swagger-api/swagger-codegen) กับ [OpenAPI Generator](https://github.com/OpenAPITools/openapi-generator) โดยทั้ง 2 ตัวเมื่อใช้งานจะได้ผลลัพธ์ที่คล้ายกัน ทั้งนี้ เนื่องจากเครื่องมือที่ชื่อ OpenAPI Generator เป็นโปรเจคที่ Fork มาจาก Swagger Codegen\n\nเครื่องมือประเภทนี้มีข้อดีคือ มันช่วยให้เราสามารถสร้าง Application โดยไม่ต้องเสียเวลาในวางโครงสร้างโปรเจคและเตรียมฟังก์ชันในเบื้องต้น ข้อเสียก็คือ เป็นการทำให้ API Specification ไม่เป็น **“Single source of truth”** (แหล่งข้อมูลจริงอยู่ที่เดียว) อีกต่อไป เพราะว่าเมื่อใช้เครื่องมือประเภทนี้ช่วยสร้างโปรเจค จะมี API Specification อีกไฟล์ปรากฎอยู่ในโปรเจคด้วย ที่มันเป็นอย่างนั้น เพราะว่าในโปรเจคที่ Generator บางตัวสร้างมีเครื่องมืออีกประเภทที่ต้องใช้กับ API Specification แถมมาให้ใช้งาน เช่นพวก API Tester, API Request Validation (จะพูดถึงในหัวข้อต่อไป) ด้วย ทำให้เราต้องคอยปรับปรุง API Specification ที่อยู่ในโปรเจคให้ตรงกับ API Specification ที่เราใช้สร้าง Application ไปตอนแรก หากมีการเปลี่ยนแปลงในไฟล์ Specification นั้น\n\nในกรณีที่มีการปรับปรุง API Specification เช่น เพิ่ม/ลด API Endpoint เราสามารถใช้เครื่องมือสร้างทับ Application เดิมได้ แต่ต้องระวังว่า มันจะเขียนทับไฟล์ทั้งหมดที่มีอยู่ตั้งแต่ตอนสร้าง ส่งผลทำให้ Code ใด ๆ ที่เราเขียนเพิ่มเติมทั้งหมดในไฟล์เหล่านี้หายไป แต่หากต้องการใช้เครื่องมือเพื่ออัพเดท API ที่มีอยู่จริง ๆ ในโปรเจคที่สร้างจะมีไฟล์หนึ่งที่ชื่อว่า `openapi-generator-ignore` (ถ้าสร้างด้วย Swagger Codegen จะมีชื่อไฟล์ว่า `.swagger-codegen-ignore`) ทำหน้าที่ป้องกันไม่ให้ Generator เขียนทับไฟล์ตามที่ระบุ เราสามารถเขียนชื่อไฟล์ที่ต้องการโดยใช้รูปแบบเดียวกับที่ใช้ใน `.gitignore` ก่อนที่จะใช้เครื่องมือในครั้งต่อไป\n\n## เครื่องมือช่วยสร้างเอกสาร\n\nในที่นี้จะขอยกตัวอย่างเครื่องมือสร้างเอกสารที่เป็นที่นิยม 4 ตัวด้วยกัน ดังนี้\n\n[**Swagger UI**](https://swagger.io/tools/swagger-ui/) เป็นเครื่องมือสร้างเอกสารตัวหนึ่งที่เป็น Open Source ถูกพัฒนาโดยบริษัท Smart Bear (เช่นเดียวกับ Swagger Codegen) เอกสารต่าง ๆ ที่ถูกสร้างขึ้นโดยโปรแกรมนี้จะมีลักษณะเป็น Interactive Documentation แสดงข้อมูลครบ เข้าใจง่าย มีช่องทางให้ผู้อ่านเอกสารทุกคน ไม่ว่าจะเป็นผู้พัฒนาและลูกค้า สามารถติดต่อกับ API ผ่านเอกสารนี้ได้อย่างง่ายดาย\n\n![](/assets/image/post/intro-to-openapi/08.png)\n\n*ตัวอย่างหน้าเอกสารที่สร้างจาก Swagger UI*\n\n[**Redoc**](https://github.com/Redocly/redoc) เป็นเครื่องมือสร้างเอกสารประเภท Interactive Document ผู้สร้างเอกสารสามารถตกแต่งเอกสารได้ตามที่ต้องการเหมือนที่ทำกับหน้าเว็บทั่วไป หากใช้ React พัฒนาเว็บไซต์ก็สามารถใช้งาน Redoc เป็น Component ตัวหนึ่งได้ เอกสารที่ถูกสร้างขึ้นจะสามารถอ่านได้ในทั้ง Desktop และ Mobile มีส่วนที่ให้ผู้อ่านสามารถคลิกเพื่อเปิดดู หรือซ่อนรายละเอียดของ Object เช่น Schema, Parameter, Request Body, Response เป็นต้น และสามารถดูการเรียกใช้ API ด้วยภาษาโปรแกรมต่าง ๆ (แต่ไม่มีที่ให้เรียกใช้ API เหมือน Swagger UI)\n\n![](/assets/image/post/intro-to-openapi/09.png)\n\n*ตัวอย่างหน้าเอกสารที่สร้างจาก Redoc จาก [Github ของ Redoc](https://github.com/Redocly/redoc)*\n\n**OpenAPI Generator** นอกจาก Application แล้ว ยังสามารถสร้างเอกสารในรูปแบบต่าง ๆ ได้ ในที่นี้จะแสดงตัวอย่างสร้างเอกสารโดยใช้ Generator ชื่อ `html`, `html2`, `dynamic-html` และ `markdown`\n\n**HTML —** Generator ตัวนี้จะสร้างหน้าเว็บง่าย ๆ เป็นไฟล์ HTML เพียงไฟล์เดียว\n\n```\nopenapi-generator generate -i petstore.yaml -g html -o petstore-document\n```\n\nด้านบนเป็นตัวอย่างคำสั่งสร้างเอกสารในรูปแบบนี้ ผลลัพธ์ที่ได้จะมีไฟล์ที่ชื่อว่า `index.html` อยู่ในโฟลเดอร์ตามที่กำหนดใน `-o` เมื่อเปิดไฟล์นี้ จะพบกับเอกสารที่มีหน้าตาตามตัวอย่าง\n\n![](/assets/image/post/intro-to-openapi/10.png)\n\n*ตัวอย่างหน้าเอกสารที่สร้างจาก Generator “html” ของ OpenAPI Generator*\n\nยังมี Generator ที่สร้าง HTML อีกรูปแบบหนึ่ง คือ **HTML2**\n\nGenerator ตัวนี้จะสร้างเอกสารในรูปแบบ HTML ที่สวยงามกว่ารูปแบบแรก\n\n```\nopenapi-generator generate -i petstore.yaml -g html2 -o petstore-document\n```\n\n![](/assets/image/post/intro-to-openapi/11.png)\n\n*ตัวอย่างหน้าเอกสารที่สร้างจาก Generator “html2” ของ OpenAPI Generator*\n\nGenerator ชื่อ **dynamic-html** สามารถสร้างไฟล์ HTML ได้เช่นกัน แต่จะสร้างเป็นชุดของไฟล์ มีทั้ง HTML แยกตาม Operation และ Model (Schema), ไฟล์ CSS, ไฟล์ Javascript และต้องรันด้วย Node.js ถึงจะแสดงหน้าเว็บสมบูรณ์ รูปแบบนี้จะโหลดเนื้อหาค่อนข้างช้าเพราะมีการรัน JavaScript (JQuery) เพื่อ Render เว็บแต่ละหน้า\n\n![](/assets/image/post/intro-to-openapi/12.png)\n\n*ตัวอย่างหน้าเอกสารที่สร้างจาก Generator “dynamic-html” ของ OpenAPI Generator*\n\n**Markdown —** OpenAPI Generator สามารถสร้างเอกสารในรูปแบบ Markdown (.md) ได้เช่นกัน\n\n```\nopenapi-generator generate -i petstore.yaml -g markdown -o petstore-document\n```\n\nเมื่อรันคำสั่งนี้ จะได้ชุดไฟล์ Markdown ที่ประกอบด้วยหน้าหลัก (`README.md`) และหน้าของแต่ละ Operation และ Model (Schema) ซึ่งแต่ละหน้ามีลิงก์เข้าไปดูหน้าของกันและกันได้\n\n![](/assets/image/post/intro-to-openapi/13.png)\n\n*ภาพแสดงชุดไฟล์ .md, หน้าตาของไฟล์ [README.md](http://README.md) และหน้าตาของ [README.md](http://README.md) เมื่อแสดงผลในเว็บที่ Render Markdown ได้*\n\n## Slate & Widdershins\n\n[**Slate**](https://github.com/slatedocs/slate) เป็นตัวช่วยสร้างเอกสารจาก Markdown ที่มีคุณสมบัติเด่นคือ เป็น Single Page ที่มีความสวยงามและ Responsive รองรับแสดงตัวอย่างโค้ดจากหลากหลายภาษาโปรแกรม โดยไม่ต้องกำหนด Config ใด ๆ\n\n![](/assets/image/post/intro-to-openapi/14.png)\n\n*ตัวอย่างหน้าเว็บเอกสารที่สร้างจาก Slate*\n\nเนื่องจาก Slate เป็นโปรแกรมพัฒนาด้วย Ruby การสร้างเอกสารด้วย Slate นั้นจึงต้องติดตั้ง Ruby ในเครื่อง รวมถึง Bundler ซึ่งเป็น Package Manager ของ Ruby ด้วย\n\nMarkdown ใน Slate จะมีลักษณะเนื้อหาที่ต้องเพิ่มที่เฉพาะตัวอยู่บ้าง บางทีต้องใช้เครื่องมือช่วยในการสร้าง Markdown สำหรับใช้ใน Slate\n\nสำหรับ OpenAPI นั้น มีเครื่องมือที่สามารถเปลี่ยน Specification ให้เป็น Markdown เช่นนั้นได้ นั่นก็คือ [Widdershins](https://github.com/Mermade/widdershins)\n\nWiddershins เป็นโปรแกรมประเภท CLI ที่สามารถติดตั้งผ่าน NPM ได้\n\n```\nnpm install -g widdershins\n```\n\nคำสั่งแปลงเอกสารที่เรียบง่ายที่สุดจะเป็นดังนี้\n\n```\nwiddershins petstore.yaml -o petstore-markdown.md\n```\n\nเมื่อแปลงเสร็จแล้วจะได้ไฟล์ Markdown (ในคำสั่งตัวอย่างจะเป็นไฟล์ที่มีชื่อว่า `petstore-markdown.md`) ที่มีลักษณะดังรูป\n\n![](/assets/image/post/intro-to-openapi/15.png)\n\n*ลักษณะ Markdown ที่สร้างจาก Widdershins*\n\nถึงตรงนี้ก็จะสามารถนำ Markdown ที่ได้นี้ ไปให้ Slate สร้างเอกสารได้ ซึ่งวิธีการสร้างจะมีอธิบายใน Github ของ Slate\n\n## เครื่องมือช่วยสร้าง Mock API Server\n\nOpenAPI Specification สามารถนำไปสร้าง Mock API ที่มีการใช้งานเหมือน REST API จริงได้เพื่อนำไปแสดงให้ลูกค้า หรือให้ Frontend Developer นำไปเรียกใช้ได้โดยไม่ต้องเขียนโค้ดเพิ่มเติม เครื่องมือที่นิยมใช้ก็คือ [Prism](https://stoplight.io/open-source/prism/)\n\n![](/assets/image/post/intro-to-openapi/16.png)\n\n*รูปแสดงหน้าเว็บของ Prism — [stoplight.io/open-source/prism/](https://stoplight.io/open-source/prism/)*\n\n**Prism** เป็นโปรแกรมที่มีความสามารถ 2 อย่าง หนึ่งคือ สามารถสร้าง REST API ปลอมที่มีการตรวจสอบข้อมูลขาเข้า และส่งข้อมูลออก (Response) ใกล้เคียงกับ API จริง สองคือ สามารถสร้าง Proxy Server ที่ Redirect ไปยัง REST API ตัวจริงได้ เพื่อช่วยให้ทางฝั่ง Frontend สามารถเชื่อมต่อง่ายขึ้น ซึ่ง Proxy ตัวนี้เราสามารถตรวจสอบได้ว่าเมื่อเราส่ง Request ไปให้ API Endpoint จะเกิดอะไรขึ้นบ้าง? และได้ Response อย่างที่เราเขียนใน Specification หรือไม่?\n\nในหัวข้อนี้จะแสดงถึงความสามารถของ Prism โดยสรุป\n\n**Validation**\n\nMock API ของ Prism มีการ Validate ข้อมูลที่ส่งมาให้ด้วย ถ้าเราลองส่งค่าผิดไปจาก Specification เช่น ส่ง String ไปเป็นตัวเลข ไม่ได้ส่งค่าที่ Required หรือไม่ได้ส่ง API Key ทาง Header มันก็จะส่ง Response ตอบกลับเป็น Error ดังตัวอย่าง\n\n![](/assets/image/post/intro-to-openapi/17.png)\n\n*Response ที่ได้รับเมื่อส่ง Request Body ที่มี [category.name](http://category.name/) เป็นตัวเลข (Specification กำหนดไว้ว่าต้องส่งเป็น String)*\n\n![](/assets/image/post/intro-to-openapi/18.png)\n\n*Response ที่ได้รับเมื่อเราส่ง Request Body ที่ไม่มี name และ photoUrl (Specification กำหนดว่าต้องมี)*\n\n**Response**\n\nค่าใน Response โดยปกติ ถ้าไม่ได้กำหนดค่าตัวอย่าง จะแสดงค่าเป็น default ตามชนิดข้อมูล เช่น ตัวเลข จะแสดงเป็น 0 ข้อความจะแสดงเป็น “string” Boolean จะแสดงค่าเป็น true เป็นต้น\n\n![](/assets/image/post/intro-to-openapi/19.png)\n\n*รูปแสดง Response เป็นค่า Default*\n\nแต่ถ้ากำหนดค่าตัวอย่างใน Schema ตัวหนึ่ง อย่างตัวอย่างนี้\n\n```yaml\ntype: object\n  properties:\n      name:\n          type: string\n          example: doggie\n```\n\nผลลัพธ์ที่ได้หากมีการใช ้Response เป็น Schema ที่มี Properties ชื่อ “name” นี้ เมื่อทำ Mock API และเรียก API ที่มีการใช้ Response ดังกล่าว จะเห็นว่ามีคำว่า doggie ตามที่กำหนดปรากฎด้วย\n\n![](/assets/image/post/intro-to-openapi/20.png)\n\n*รูปแสดง Response ที่ Property ชื่อว่า “name” ชื่อว่า “doggie” ตามที่กำหนดไว้ใน Specification*\n\nถ้าเรากำหนด Response ตัวหนึ่งมี Example Object อย่างเช่น\n\n```yaml\n/user/{username}:\n    get:\n      tags:\n        - user\n      summary: Get user by user name\n      description: ''\n      operationId: getUserByName\n      parameters:\n        - name: username\n          in: path\n          description: The name that needs to be fetched.\n          required: true\n          schema:\n            type: string\n      responses:\n        '200':\n          description: successful operation\n          content:\n            application/xml:\n              schema:\n                $ref: '#/components/schemas/User'\n              examples:\n                user1:\n                  value:\n                    id: 10\n                    name: Jessica Smith\n        '400':\n          description: Invalid username supplied\n        '404':\n          description: User not found\n```\n\nเมื่อเราใช้ API ที่ส่ง Response ดังกล่าว Mock API จะส่ง Response เป็น Example Object นั้นมาแทน ดังรูป\n\n![](/assets/image/post/intro-to-openapi/21.png)\n\n*รูปแสดง Response ที่แสดงเป็นค่าตาม Example ตามที่กำหนดไว้ใน Specification*\n\n\n**Dynamic Response**\n\nหากไม่มีพวก Example Object เราสามารถให้ Mock API สร้างค่าเองได้ โดยรัน API ด้วยคำสั่งใหม่ ที่มี `-d` (Dynamic Response)\n\n```\nprism mock -d petstore.yaml\n```\n\nเมื่อลองใช้ API ตัวหนึ่ง ก็จะพบว่า Mock API ก็จะสุ่มค่ามั่ว ๆ ให้ดังตัวอย่าง\n\n![](/assets/image/post/intro-to-openapi/22.png)\n\n*รูปแสดง Response เป็นแบบ Dynamic*\n\nMock API จะสุ่มค่ามั่ว ๆ เช่นนี้ให้กับทุก Field ข้อมูลในทุก Schema ถึงแม้ว่า Schema หรือ Response นั้นจะมี Example Value/Object รองรับก็ตาม เมื่อเราต้องการรัน Mock API ในโหมดนี้ เราต้องกำหนดลักษณะเฉพาะให้กับทุก Field นอกจาก type เพื่อให้ได้ค่าที่มีลักษณะใกล้เคียงหรือเดียวกับที่เราต้องการ\n\n```yaml\n/example:\n    get:\n      responses:\n        '200':\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  email:\n                    type: string\n                    format: email\n                  age:\n                    type: integer\n                    minimum: 0\n                    maximum: 100\n```\n\nจากตัวอย่าง เมื่อเราใช้ API ตัวนี้ เราจะได้ Response ดังตัวอย่างนี้\n\n![](/assets/image/post/intro-to-openapi/23.png)\n\n*รูปแสดง Response เป็นแบบ Dynamic ที่มีลักษณะเจาะจงมากขึ้น*\n\nจากภาพตัวอย่าง จะเห็นได้ว่า เมื่อเรากำหนดลักษณะเฉพาะของแต่ละ Field ค่าที่อยู่ใน Response จะมีลักษณะตรงกับที่กำหนด แต่ข้อมูลบางส่วนก็จะดูมั่ว ๆ อยู่ดี เพื่อให้ได้ค่าที่ใกล้เคียงกับความเป็นจริงมากขึ้น เราสามารถให้ Prism ทำการสุ่มค่าเช่นนั้น โดยกำหนด Property พิเศษชื่อ x-faker ให้กับ Field ข้อมูลที่ต้องการ ค่าของ x-faker จะต้องเป็นชื่อฟังก์ชันตามที่แสดงใน[หน้าเว็บนี้](https://rawgit.com/Marak/faker.js/master/examples/browser/index.html) (มาจาก Library ที่ชื่อว่า [Faker.js](https://github.com/marak/Faker.js))\n\n```yaml\n/example:\n    get:\n      responses:\n        '200':\n          description: successful operation\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  email:\n                    type: string\n                    format: email\n                    x-faker: internet.email\n                  age:\n                    type: integer\n                    minimum: 0\n                    maximum: 100\n```\n\nจากตัวอย่าง เมื่อเราใช้ API ตัวนี้ เราจะได้ Response ดังตัวอย่างนี้\n\n![](/assets/image/post/intro-to-openapi/24.png)\n\n*รูปแสดง Response เป็นแบบ Dynamic ที่มีลักษณะเจาะจงจากการใช้ x-faker*\n\n## เครื่องมือช่วย Validate API\n\nหากเราทำตามกระบวนการ **API Design-First Appoarch** เราจะสามารถทำ Testing และ Validation กับ REST API ได้อย่างง่ายดาย และใช้เวลาไม่นาน เพราะในเมื่อ OpenAPI Specification ถูกสร้างมาตั้งแต่ขั้นตอน Design แล้ว เราก็สามารถนำมันทำงานกับเครื่องมือที่ทำหน้าที่สองอย่างนี้ให้นั่นเอง\n\nเครื่องมือประเภทนี้จะทำหน้าที่เป็นตัวกลาง หรือ Middleware ของ REST API ช่วยกรองข้อมูลขาเข้าให้ โดยเมื่อผู้ใช้ส่ง Request เข้ามายัง REST API ของเราผ่าน API Endpoint ตัวหนึ่ง เครื่องมือตัวนี้ก็จะนำ Request ที่ได้รับไปเทียบกับข้อมูลของ API Endpoint ที่เราเขียนใน Specification ว่าตรงกันหรือไม่ หากตรงกัน ก็จะให้ REST API ทำตาม Logic ปกติ แต่ถ้าไม่ มันก็จะส่ง Response บอกความผิดพลาดออกมา\n\nการทำงานแบบนี้ยังช่วยในเรื่องของ Testing ให้ด้วย กล่าวคือ ทำให้เรารู้ได้ว่า ที่จริงแล้ว REST API สามารถรับข้อมูลได้ตรงตามที่เขียนไว้ใน Specification หรือไม่\n\nในหัวข้อนี้จะยกตัวอย่างเครื่องมือตัวหนึ่ง คือ\n\n**Prism** ตัวเดียวกับตัวที่กล่าวถึงในหัวข้อที่แล้วนี่เอง เพราะ Prism นอกจาก Mock API ได้แล้ว ยังสามารถสร้าง Proxy Server ได้ ซึ่ง Proxy ตัวที่สร้างขึ้นจะเป็นด่านหน้าของ REST API ช่วยดักจับ Request มาตรวจสอบ\n\nการสร้าง Proxy Server ด้วย Prism สามารถทำได้ด้วยคำสั่งนี้\n\n```\nprism proxy petstore.yaml localhost:3000\n```\n\nคำสั่งดังกล่าว จะเปิด Proxy ที่ Forward ไปที่ API ตามที่อยู่ `localhost:3000` โดยใช้ Specification `petstore.yaml` ช่วยกรองและตรวจสอบ Request ต่าง ๆ ที่เข้ามา และ Response ที่ API ตัวนี้ส่งออก เสร็จแล้ว เราก็ใช้งาน API ตามที่อยู่ที่ Prism ให้ Response ที่ส่งมาจะเหมือนกับ REST API ที่ Mock โดยใช้ Prism\n\n![](/assets/image/post/intro-to-openapi/25.png)\n*ภาพแสดงผลลัพธ์จากการเปิดใช้งาน Proxy Server ของ Prism*\n\n![](/assets/image/post/intro-to-openapi/26.png)\n\n*Proxy Server จะช่วย Debug สิ่งที่เกิดขึ้นเมื่อมีการใช้งาน REST API ผ่าน Proxy ดังรูปตัวอย่างนี้*\n\nทั้งนี้สามารถอ่านข้อมูลเพิ่มเติมได้ที่ Documentation ของ Prism\n\n# สรุปและทิ้งท้าย\n\nในบทความนี้ จะเห็นได้ว่า OpenAPI Specification นั้นช่วยให้เราสามารถเขียนคำอธิบายถึงลักษณะของ REST API ได้ครบถ้วน คำอธิบายนั้นประกอบด้วย ชื่อ, เวอร์ชันปัจจุบัน, ข้อมูลการติดต่อ, ลิขสิทธิ์, Server ที่ตั้ง REST API, Path ต่าง ๆ, รวมไปถึงโครงสร้างข้อมูลที่ใช้ใน REST API การเขียน Specification สามารถทำได้ใน Swagger Editor และ Text Editor ทั่วไป รวมถึงพวก GUI Editor อย่างเช่น Stoplight Studio, Apicurio Studio เป็นต้น เมื่อเขียนเสร็จแล้ว นอกจากจะเป็นเอกสารสำคัญ ยังสามารถเป็นตัวช่วยพัฒนา REST API อีกด้วย ในบทความนี้ได้แสดงให้เห็นถึงความสามารถของ OpenAPI Specification ในการเป็นตัวช่วย 4 อย่าง คือ Generate Applications, Documentation, Mock API, และการ Validate API\n\nที่จริงเครื่องมือที่ทำงานกับ OpenAPI Specification มีไม่หมดเพียงแค่นี้ ยังมีเครื่องมืออื่น ๆ อีกมากมาย หากเราต้องการเครื่องมือใช้งานเพิ่มเติม ผู้เขียนขอแนะนำเว็บหนึ่งที่รวบรวมเครื่องมือสร้าง Specification และเครื่องมือที่ทำงานร่วมกับ Specification เพื่อสร้างสิ่งต่าง ๆ ตามที่เราต้องการ เว็บนี้มีชื่อว่า [OpenAPI.tools](https://openapi.tools/) สามารถเข้าไปดูได้เลยค่ะ\n\nขอขอบคุณผู้อ่านทุกคนที่อ่านบล็อกนี้จนจบด้วยนะคะ กด 👏 เพื่อเป็นกำลังใจให้ให้ผู้เขียนได้ ถ้ามีคำแนะนำหรือคำติชมอะไร สามารถ Comment ได้เลยนะคะ\n\nพบกันใหม่ในบล็อกหน้า สวัสดีค่ะ\n\n# Credit & References\n\n- [OpenAPI Specification in Wikipedia](https://en.wikipedia.org/wiki/OpenAPI_Specification)\n\n- [A Guide to What's New in OpenAPI 3.0](https://swagger.io/blog/news/whats-new-in-openapi-3-0/)\n\n- [About Swagger Specification](https://swagger.io/docs/specification/about/)\n\n- [Understanding the API-First Approach to Building Products](https://swagger.io/resources/articles/adopting-an-api-first-approach/)\n\n- [API Design-First vs Code First](https://apisyouwonthate.com/blog/api-design-first-vs-code-first)\n\n- [Implement an API Design-first approach for building APIs](https://hub.packtpub.com/implementing-an-api-design-first-approach-for-building-apis/)\n\n- [There's No Reason to Write OpenAPI By Hand](https://apisyouwonthate.com/blog/theres-no-reason-to-write-openapi-by-hand)\n\n- [OpenAPI.Tools](https://openapi.tools/)\n\n**Icons (Used in image of API Design-Fist Approach)**\n\n*   Marker — [Freepik](https://www.flaticon.com/authors/freepik)\n*   Model — [Skyclick](https://www.flaticon.com/authors/skyclick)\n*   Document — [Smalllikeart](https://www.flaticon.com/authors/smalllikeart)\n*   Customer — [Ultimatearm](https://www.flaticon.com/authors/ultimatearm)\n*   Coding — [Prettycons](https://www.flaticon.com/authors/prettycons)\n*   Chemistry — [Surang](https://www.flaticon.com/authors/surang)\n*   Launch — [Icongreek26](https://www.flaticon.com/authors/icongeek26)\n\n---\n\n*This article was originally published at [Medium.com](https://medium.com/@icegotchafantasoxy/openapi-specification-101-f07a1b6da238)*\n"},{"slug":"how-to-use-schemaspy","category":"posts","title":"แนะนำ SchemaSpy เครื่องมือทำเอกสาร Database","description":"มาดูวิธีการสร้างคลังข้อมูลที่เกี่ยวกับ Database ของเราภายในไม่กี่วินาทีด้วย SchemaSpy กัน","tags":["database","documentation","tools","schemaspy"],"body":"\nถ้าระบบของเรามีฐานข้อมูลที่เป็น Rational Database การทำเอกสารเกี่ยวกับมันเป็นงานที่สำคัญ เพราะจะทำให้ทุกคนที่เกี่ยวข้องเข้าใจการเก็บข้อมูลในระบบของเรามากขึ้น แต่ด้วยความซับซ้อนของมัน งานนี้จึงเป็นงานที่ใช้เวลาทำนานและค่อนข้างน่าเบื่อ ในปัจจุบัน มีเครื่องมือช่วยสร้างเอกสารให้เรามากมาย มีทั้งฟรีและไม่ฟรี ในบทความนี้ ผู้เขียนจะแนะนำให้คุณผู้อ่านรู้จักกับเครื่องมือตัวหนึ่ง ที่มีขนาดเล็ก ใช้งานง่าย เก็บข้อมูลได้ครบ ที่สำคัญคือ **ฟรี!** เครื่องมือตัวนี้มีชื่อว่า **SchemaSpy**\n\n# SchemaSpy คืออะไร?\n\n**SchemaSpy** เป็นโปรแกรมประเภท Command Line เขียนด้วยภาษา Java มันจะช่วยวิเคราะห์ เก็บข้อมูลของฐานข้อมูลของเรา และสร้างเอกสารออกมาเป็นเว็บที่สวยงาม ภายในเอกสารนอกจากจะมีข้อมูลเกี่ยวกับตารางและส่วนอื่น ๆ ที่จำเป็นแล้ว ยังมีแผนภาพ ER Diagram ให้เราอีกด้วย\n\n![รูปแสดงตัวอย่างเอกสารที่สร้างขึ้นจาก SchemaSpy](/assets/image/post/how-to-use-schemaspy/00.png)\n\nรูปภาพที่แสดงอยู่นี้คือตัวอย่างเอกสาร Database ที่ SchemaSpy สร้างขึ้น สามารถดูได้ที่ [http://schemaspy.org/sample/index.html](http://schemaspy.org/sample/index.html)\n\n# ก่อนที่จะใช้งาน SchemaSpy\n\n## ติดตั้ง JRE ลงเครื่อง\n\nก่อนที่จะใช้งาน SchemaSpy จะต้องมี JRE (Java Runtime Environment) เวอร์ชัน 8 หรือมากกว่าในเครื่องคอมของเราก่อน ถ้ายังไม่มีก็สามารถดาวน์โหลไฟล์ติดตั้งได้ที่เว็บ [java.net](https://www.java.com/en/download/manual.jsp) แลัวติดตั้งลงเครื่องให้เรียบร้อย\n\n![รูปเว็บไซต์ java.net](/assets/image/post/how-to-use-schemaspy/01.png)\n\n> ถ้าคุณผู้อ่านใช้ Ubuntu ปกติมันจะมี JRE 8 อยู่ในเครื่องอยู่แล้ว แต่ถ้าไม่มี หรือต้องการติดตั้งเวอร์ชันอื่นเพิ่มก็สามารถดูและทำตาม[บทความของ DigitalOcean](https://www.digitalocean.com/community/tutorials/how-to-install-java-with-apt-on-ubuntu-20-04) ได้เลย\n\n## ดาวน์โหลด JDBC Driver\n\nเมื่อมี JRE ในเครื่องแล้วก็ให้ดาวน์โหลด **JDBC Driver** หรือ **Connector/J** ตามชนิดหรือยี่ห้อของ Database ที่ใช้งานอยู่ ตัวนี้จะทำหน้าที่เชื่อมต่อ Database เข้ากับโปรแกรมที่เขียนด้วย Java อย่าง SchemaSpy ในที่นี้จะแสดงวิธีการดาวน์โหลด JDBC Driver ของฐานข้อมูลที่เรานิยมใช้กัน ได้แก่ MySQL, MariaDB, Postgresql และ Microsoft SQL Server (ขอย่อว่า MSSQL)\n\n### MySQL\n\nเข้าไปที่เว็บ URL [https://dev.mysql.com/downloads/connector/j/](https://dev.mysql.com/downloads/connector/j/) เลือก \"**Platform Independent\"** ที่ **Select Operating System** รอสักครู่ มันจะ Render รายการไฟล์แสดงบนเว็บ เมื่อมีรายการออกมาแล้ว ให้คลิกปุ่ม Download ที่อยู่แถว `ZIP Archive` เราจะได้ไฟล์ zip ไฟล์หนึ่ง\n\n![รูปหน้าจอดาวน์โหลดของเว็บไซต์ MySQL เมื่อเลือก \"Platform Independent\" จะแสดงรายการไฟล์ขึ้นมา 2 รายการ คือ ไฟล์รูปแบบ .tar.gz และ .zip](/assets/image/post/how-to-use-schemaspy/02.png)\n\nภายในมีไฟล์ JAR ที่ชื่อว่า `mysql-connector-java-[version]` ให้เก็บไฟล์นี้ไว้\n\n![รูปแสดงภายในไฟล์ zip จะมีไฟล์ที่ชื่อ mysql-connector-java ตามด้วย version ของไฟล์ ลงท้ายด้วย .jar](/assets/image/post/how-to-use-schemaspy/03.png)\n\n### MariaDB\n\nเข้าไปที่เว็บ URL [https://downloads.mariadb.org/connector-java/](https://downloads.mariadb.org/connector-java/) คลิกปุ่ม **Download Now!** ที่เวอร์ชันล่าสุด\n\n![รูปหน้าเว็บไซต์ MariaDB จะมีกรอบแสดง Version เป็น Series ให้เลือกดาวน์โหลด](/assets/image/post/how-to-use-schemaspy/04.png)\n\nเลือกแหล่งดาวน์โหลดที่ Mirror และคลิกที่ลิงก์ในช่อง File name แถวที่ **Package Type** เป็น **Jar**\n\n![รูปหน้าจอดาวน์โหลดไฟล์ Connector/J ของเว็บไซต์ MariaDB มีตารางแสดงรายการไฟล์ที่ดาวน์โหลดได้อยู่ด้านซ้าย ซึ่งจะเป็นไฟล์ JAR ที่มีซอร์สโค้ด แลพที่ไม่มีซอร์สโค้ด  และกรอบแสดงแหล่งดาวน์โหลด (Mirror) อยู่ด้านขวา](/assets/image/post/how-to-use-schemaspy/05.png)\n\nคลิกที่ `mariadb-java-client-[version].jar`\n\n![รูปหน้าจอรายการไฟล์ Connector/J เป็นไฟล์ JAR ที่ไม่มีซอร์สโค้ดของเว็บไซต์ MariaDB เราต้องเลือกไฟล์ที่ชื่อ mariadb-java-client ตามด้วยเวอร์ชัน และลงท้ายด้วย .jar](/assets/image/post/how-to-use-schemaspy/06.png)\n\n\nเราจะได้ JDBC Driver ของ MariaDB เป็นไฟล์ JAR ในเครื่อง\n\n### Postgresql\n\nเข้าไปที่เว็บ URL [https://jdbc.postgresql.org/download.html](https://jdbc.postgresql.org/download.html) ให้คลิกดาวน์โหลดที่ลิงก์ในส่วนของ **Current Version** (เวอร์ชันล่าสุด) หรือ **Other Versions** แล้วเราจะได้ไฟล์ JAR มาหนึ่งไฟล์\n\n![รูปเว็บไซต์ดาวน์โหลด JDBC ของ Postgresql](/assets/image/post/how-to-use-schemaspy/07.png)\n\n### Mssql\n\nเข้าไปที่เว็บ URL [https://docs.microsoft.com/en-us/sql/connect/jdbc/download-microsoft-jdbc-driver-for-sql-server](https://docs.microsoft.com/en-us/sql/connect/jdbc/download-microsoft-jdbc-driver-for-sql-server) จากนั้นคลิกที่ **`Download Microsoft JDBC Driver [version] for SQL Server (zip)`** เราจะได้ไฟล์ zip ให้คลาย zip ออกมา ภายในจะมีไฟล์ JAR อยู่หลายไฟล์ แต่ละไฟล์มีชื่อลงท้ายด้วยเวอร์ชันของ JRE ให้เก็บไฟล์ที่มีชื่อเวอร์ชัน JRE ตรงกับเวอร์ชันที่เราลงในเครื่อง\n\n![รูปแสดงไฟล์ Connector/J ของ MSSQL ในที่นี้มีไฟล์ JAR 3 ไฟล์ แต่ละไฟล์จะมีชื่อลงท้ายด้วย JRE คือ .jre8, .jre11 และ .jre15](/assets/image/post/how-to-use-schemaspy/08.png)\n\n## ติดตั้ง GraphViz\n\n**GraphViz** เป็น Package หนึ่งที่ช่วยวาดแผนภาพที่มีการเชื่อมโยงกันเป็นเครือข่ายและ Graph เช่น Flow Chart, Data Model เป็นต้น SchemaSpy ใช้ตัวนี้ในการวาด ER Diagram เราจึงจำเป็นต้องติดตั้งมันลงในเครื่องด้วย การติดตั้งสามารถดูได้ที่[เว็บไซต์ของ GraphViz](https://graphviz.org/download/)\n\nสำหรับการติดตั้งใน Windows วิธีการที่ง่ายที่สุดคือ ติดตั้งผ่าน Chocolatey หรือ WinGet\n\n```bash\n// Chocolatey\n> choco install graphviz\n\n// WinGet\n>  winget install graphviz\n```\n\nหากเราไม่มี Chocolatey หรือ WinGet ก็ดาวน์โหลดตัวติดตั้งเป็นไฟล์ `.exe` ในเว็บไซต์ของ GraphViz และดับเบิ้ลคลิกที่ไฟล์เพื่อติดตั้ง เมื่อมาถึงหน้าจอ **Install Options** เราจะต้องเลือกให้ GraphViz เพิ่มตัวรันโปรแกรมลงใน PATH ของ Windows เพื่อให้มันสามารถถูกเรียกใช้ได้จาก Command Line\n\n![รูปแสดงหน้าจอการติดตั้ง GraphViz ในส่วนของ Install Options ต้องเลือก Add GraphViz to the system PATH for all user หรือ  Add GraphViz to the system PATH for current user เพื่อให้ GraphVizสามารถถูกเรียกใช้ได้จาก Command Line](/assets/image/post/how-to-use-schemaspy/09.png)\n\nหลังจากติดตั้งเสร็จเรียบร้อย ให้เปิด Powershell หรือ Terminal ที่ใช้งานอยู่ โดยใช้สิทธิ์ของ Administrator แล้วพิมพ์ `dot -c` เพื่อลงทะเบียน Plugin ต่าง ๆ ของ GraphViz ให้ Windows รู้จัก\n\n\n![รูปแสดงหน้าจอ Powershell ที่พิมพ์ dot -c ลงไป](/assets/image/post/how-to-use-schemaspy/10.png)\n\nต่อจากนั้นให้พิมพ์คำสั่ง `dot -v` เพื่อดูว่า GraphViz ถูกตั้งค่าเรียบร้อยแล้วหรือยัง?\n\n![รูปแสดงหน้าจอ Powershell ที่พิมพ์ dot -v ลงไป แล้วมีรายละเอียดการ Render ขึ้นมา](/assets/image/post/how-to-use-schemaspy/11.png)\n\nถ้าขึ้นเวอร์ชัน และรายละเอียดการ Render ตามรูปนี้ แสดงว่าเราได้ติดตั้ง GraphViz เสร็จสมบูรณ์แล้ว ต่อไปเราก็ดาวน์โหลด SchemaSpy มาใช้ได้เลย\n\n# การดาวน์โหลด SchemaSpy\n\nให้ดาวน์โหลดที่ [SchemaSpy.org](http://schemaspy.org/) เราก็จะได้โปรแกรม SchemaSpy เป็นไฟล์ JAR มา (ในที่นี้ได้ไฟล์ชื่อ `schemaspy-6.1.0.jar`) สามารถใช้งานได้เลย ไม่ต้องติดตั้งลงเครื่อง\n\n![รูปแสดงเว็บไซต์ schemaspy.org](/assets/image/post/how-to-use-schemaspy/12.png)\n\n# การใช้งาน SchemaSpy\n\nเปิด Terminal แล้วไปที่โฟลเดอร์ที่เราเก็บโปรแกรมด้วยคำสั่ง `cd` พิมพ์คำสั่งผ่าน Terminal รูปแบบดังนี้\n\n```bash\njava -jar schemaspy-6.1.0.jar\n     -t [database dialect]\n     -db [database name]\n     -s [schema name]\n     -host [server address]\n     -port [port]\n     -u [user]\n     -p [password]\n     -o [output path]\n     -dp [jdbc driver path]\n```\n\nตัวอย่าง\n\n```bash\njava -jar schemaspy-6.1.0.jar -t mysql -db 'sample_database' -s 'sample_database' -host 'localhost' -port 3306 -u 'root' -p '123456' -o db-output -dp ./mysql-connector-java-8.0.23.jar\n```\n\nจากคำสั่ง ให้เราแทนที่ `[...]` ที่อยู่ในแต่ละ Argument (`-xx`) ด้วยข้อมูลของ Database ของเราเอง ทั้งนี้ หากเราต้องการดูความหมายและรายละเอียดของ Argument ต่าง ๆ เพิ่มเติม ก็สามารถดูที่ [Document ของ GraphViz](https://schemaspy.readthedocs.io/en/latest/configuration/commandline.html)  ได้เลย\n\nNote เกี่ยวกับบาง Argument เล็กน้อย (เท่าที่ลองใช้งานดู):\n\n- `-t [database dialect]` มีไว้กำหนดยี่ห้อหรือชนิดของฐานข้อมูล โดยทั่วไปให้ใช้ `mysql` สำหรับ MySQL, `mariadb` สำหรับ MariaDB,  `pgsql`  หรือ `pgsql11` สำหรับ Postgresql, `mssql08` สำหรับ Microsoft SQL Server รุ่น 2008 ขึ้นไป หากเราใช้ยี่ห้ออื่นนอกเหนือจากนี้ให้พิมพ์คำสั่งนี้เพื่อดูชื่อยี่ห้อ Database ทั้งหมดที่ SchemaSpy รู้จัก\n`java -jar schemaspy-6.1.0.jar -dbhelp`\nนอกจากชื่อยี่ห้อแล้ว คำสั่งนี้ยังแสดง Argument ที่จำเป็นต้องใช้ในแต่ละยี่ห้อด้วย\n- `-s [schema name]`  มีไว้กำหนด Schema ที่เก็บตารางต่าง ๆ ใน Database บางยี่ห้อ จะมีการแบ่งหมวดหมู่เก็บตารางเป็น Schema ยกตัวอย่าง โดย Default  **Postgresql**  จะเก็บตารางต่าง ๆ ใน Schema ชื่อว่า `public` ส่วน **Microsoft SQL Server** จะเก็บตารางใน Schema ชื่อ `dbo` สำหรับ MySQL และ MariaDB จะไม่มี Schema แต่บางครั้ง SchemaSpy จะฟ้องให้ใช้ชื่อ Schema ลงไปด้วย หากเกิดเหตุการณ์นี้ขึ้นให้ใส่ชื่อ Schema เป็นชื่อเดียวกับ Database แล้วจะสร้างเอกสารได้ (Solution มาจาก [issue นี้](https://github.com/schemaspy/schemaspy/issues/329))\n- `-o db-output` ใช้กำหนด Path ของโฟลเดอร์ของเอกสารที่จะให้ SchemaSpy สร้างขึ้นมา\n- `-dp [jdbc driver path]` ใช้กำหนด Path ของ JDBC Driver เป็นไฟล์ JAR ที่เราดาวน์โหลดเก็บไว้ก่อนหน้านี้\n\nเมื่อทำคำสั่ง ผลลัพธ์ที่ถูกต้อง จะแสดงบน Terminal ดังรูปนี้\n\n![รูปแสดงผลลัพธ์หลังจากทำคำสั่ง ผลลัพธ์ที่ถูกต้องจะต้องแสดงว่า \"เขียนเสร็จในเวลา ... วินาที\"](/assets/image/post/how-to-use-schemaspy/13.png)\n\nแล้วโฟลเดอร์ตาม Path ที่กำหนดใน `-o`  จะปรากฎขึ้นมา เมื่อเราไปเปิดดูจะเห็นไฟล์และโฟลเดอร์เยอะแยะเต็มไปหมด ทั้งหมดนี้เป็นส่วนประกอบของเอกสารที่ SchamaSpy สร้างขึ้น เมื่อเราจะเปิดอ่านก็ให้ดับเบิลคลิกที่ไฟล์ `index.html` เอกสารก็จะปรากฎขึ้นมาในหน้าต่าง Browser\n"},{"slug":"say-hi-to-typescript","category":"posts","title":"สวัสดี Typescript","description":"Typescript ดียังไง? จะใช้ยังไง? มี Type อะไรบ้าง? ไปดูกัน","tags":["javascript","typescript"],"body":"\nภาษา JavaScript เป็นภาษาที่ใครหลาย ๆ คน รวมถึงผู้เขียนชื่นชอบเพราะว่าเขียนง่ายสนุกดี แถมรันได้เร็วด้วย แต่บางครั้งผู้เขียนรู้สึกเบื่อ ไม่ชอบมัน เพราะด้วยความง่าย ทำให้เรามองไม่เห็นปัญหาหลายอย่างจนต้องตามแก้อยู่นาน\n\nต่อมา ผู้เขียนก็ได้เรียนรู้ภาษาหนึ่ง ที่ทำให้กลับมารักโลก JavaScript อีกครั้งหนึ่งซึ่งก็คือ **TypeScript** ที่จะพูดถึงในบทความนี้นั่นแหละ\n\n# ปัญหาของการใช้ JavaScript\n\nภาษา Javascript เป็นภาษาที่มีการกำหนด Type แบบ Dynamic Type ดังนั้น เวลาเราสร้างตัวแปรตัวหนึ่ง เราไม่ต้องใส่ Type ให้มัน เราจะใส่ค่าให้มันยังไงก็ได้ จะเป็นตัวอักษร ตัวเลข อาร์เรย์ Object หรือแม้แต่ เป็นฟังก์ชัน ก็ได้หมด ในเวลาไหนก็ได้ด้วย\n\n```javascript\nlet variable\nvariable = 'Hello'\nvariable = 1\nvariable = []\nvariable = {\n  name: 'John'\n}\nvariable = function () {\n  return 'Hello'\n}\n```\n\nข้อดีของมัน คือ เขียนโค้ดง่าย มีอิสระ ความยืดหยุ่นสูง ทำให้สร้างโปรแกรมได้รวดเร็ว เพราะไม่ต้องวุ่นวายเรื่องการกำหนด Type ให้เสียเวลา แต่ความง่ายของมัน ก็ทำให้เกิดปัญหาและความยุ่งยากได้ง่ายเช่นกัน\n\nการที่ไม่มี Type กำกับตัวแปร ก็ทำให้เราต้องทำความเข้าใจ Structure และการใช้ตัวแปรต่าง ๆ ผ่านโค้ด ซึ่งทำให้เสียเวลามาก ยิ่งโปรแกรมใหญ่ ๆ ที่มีโค้ดซับซ้อน ก็ยิ่งใช้เวลาอ่านทำความเข้าใจมากด้วย อีกทั้งก็ยิ่งทำให้เกิดการเขียนโค้ดผิดพลาดจนทำให้เกิด Bug เยอะขึ้น\n\nด้วยความที่ Javascript เป็นภาษาประเภท Interpreted Language ไม่ใช่ Compiled Language เราจะไม่มีทางรู้ว่า *โปรแกรมที่เราเขียนมีปัญหาอะไรหรือเปล่า* จนกระทั่งเราสั่งรันโปรแกรม\n\n![Error ของ JavaScript ที่เกิดบนเว็บไซต์](/assets/image/post/say-hi-to-typescript/01.png)\n\nขอยกตัวอย่างปัญหาที่เจอบ่อย ๆ\n\nฟังก์ชันบวกเลขง่าย ๆ\n\n```javascript\nfunction add(a, b) {\n  return a + b\n}\n```\n\nเราดันเรียกใช้ตัวหนึ่งเป็น string\n\n```\nadd(1, '2')\n```\n\nเมื่อรันโปรแกรม ก็ได้ผลลัพธ์คือ '12' เป็น string กรณีนี้ถือว่าเป็น Logical Error ซึ่งเราไม่อยากให้เกิด\n\nอีกกรณีหนึ่ง คือ เผลอใช้ข้อมูลใน Object ที่ตัว Object ถูกเปลี่ยนค่าไปแล้ว อย่างโค้ดนี้\n\n```javascript\nlet a = {\n  name: 'John'\n}\n\na = null\n\nconsole.log(a.name)\n```\n\nพอรันโปรแกรม เมื่อทำงานถึงบรรทัดที่มี `console.log(a.name)` มันก็ฟ้อง Error อย่างตัวอย่างโค้ดด้านบนเมื่อรันจะเกิด Error ว่า `TypeError: Cannot read property 'name' of null`\n\nจะเห็นได้ว่า JavaScript มันจะรันโปรแกรมโดยไม่ตรวจค่าให้ มันจะอ่านคำสั่งและประมวลผลไปเรื่อย ๆ ถ้ามี Error ค่อยแสดงขึ้นมาให้เห็น ดังนั้นจะมีโอกาสหลุดขึ้นไป Production ถ้าเราไม่ตรวจสอบให้ดี ๆ\n\nError ทั้งสองข้อนี้ ถ้าเกิดกับโปรเจคเล็ก ๆ เราจะหาต้นตอได้ไม่ยาก แต่ถ้าเกิดกับโปรเจคใหญ่ ๆ การหาต้นตออาจจะใช้เวลานาน เพราะไม่มีตัวชี้ตำแหน่งชัดเจน บางทีก็ต้องใช้ Debugger ช่วย\n\n# Typescript คืออะไร? ใช้ Typescript แล้วดียังไง?\n\nTypeScript ได้ถูกสร้างและพัฒนาโดย **Microsoft** เพื่อแก้ปัญหาของ JavaScript ซึ่งเหมาะที่จะใช้ในโปรเจคขนาดใหญ่\n\nTypeScript เป็นภาษา Superset ของ JavaScript หมายความว่า โค้ดในภาษา JavaScript ทุกอย่างจะใช้ได้ใน TypeScript เพียงแต่ช่วยเพิ่ม Type system เข้าไปทำให้การเขียนโปรแกรมของเราดีขึ้น\n\nแล้วดีขึ้นยังไง?\n\n**1. ข้อนี้แน่นอนที่สุด คือ ช่วยลดการเกิด Error พวก `TypeError` ตอนโปรแกรมทำงาน**\n\n  เมื่อเราสั่งรันโปรแกรม เราจะต้องใช้ Compiler ของ TypeScript เราจะเห็น Error ตั้งแต่แรกเมื่อเราเขียนผิด ยิ่งถ้าใช้ Editor อย่างเช่น VSCode ก็จะขึ้นให้เราเห็นโดยที่เราไม่ต้องทำอะไรเลย\n\n  ![การแสดง Error ของ Typescript](/assets/image/post/say-hi-to-typescript/02.png)\n\n**2. โค้ดมีคุณภาพขึ้น**\n\n  การมี Type กำกับตัวแปร จะทำให้เราเข้าใจได้ทันทีว่าตัวแปรนั้นใช้เก็บค่าอะไร ส่งผลให้เข้าใจการทำงานในส่วนที่เกี่ยวข้องภายในเวลารวดเร็ว\n\n**3. มี Auto Complete**\n\n  Code Editor อย่าง VSCode ก็มี Auto Complete ที่เมื่อเราพิมพ์จุด (.) หลังตัวแปร แล้วมีรายการ Property และ Function ที่ตรงกับ Type ของตัวแปรขึ้นมาให้ นี่เป็นผลมาจากการทำงานของ TypeScript ที่ฝังอยู่ใน VSCode ถ้าโปรแกรมเราใช้ TypeScript ตัว Editor ก็จะประมวลผล Auto Complete ให้เราใช้เร็วและบ่อยกว่า JavaScript\n\n  ![การมี Auto complete ของ VSCode](/assets/image/post/say-hi-to-typescript/03.png)\n\n\n**4. ไม่ Strict เท่า Strict Type Language**\n\n  แม้ TypeScript จะทำให้เราต้องกำหนด Type และ Strict เรื่องใช้ตัวแปรมากขึ้น แต่ก็ไม่ได้ Strict ถึงขนาดต้องใส่ Type ให้กับทุกตัวที่เราใช้ในโปรแกรม เหมือนอย่างภาษาที่ Strict หนัก ๆ อย่างเช่น ภาษา Java ตัว TypeScript เองก็เปิดให้เราเลือกได้ว่าจะใส่ Type หรือไม่ใส่ Type อย่างไรบ้าง เช่น\n\n```javascript\n// ตัวแปร ต้องใส่ type นะ\ncost a: number = 10;\n\n// ฟังก์ชัน ไม่ต้องใส่ return type ก็ได้\nfunction add(a: number, b: number) {\n  return a + b;\n}\n```\n\n# อยากใช้บ้างต้องทำไง?\n\nTypeScript ใช้ได้ในโปรเจคที่ใช้ Environment เป็น Node.js หรือ Deno ถ้าเป็น Frontend ก็เป็นพวก Framework ที่นิยมใช้กัน อย่างเช่น React.js, Vue.js ในที่นี้จะขอพูดถึงการเพิ่ม TypeScript ใน Node.js ธรรมดาอย่างเดียวก่อน\n\nเราสามารถติดตั้งผ่าน `npm`\n\n```\nnpm install typescript --save-dev // local\nnpm install typescript -g // global\n```\n\nจากนั้นให้เราสร้างไฟล์ `tsconfig.json` ในโปรเจคซึ่งมีเนื้อหาประมาณนี้\n\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2015\",\n    \"module\": \"commonjs\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true\n  },\n}\n```\n\nมันเป็นไฟล์ Config ของ TypeScript ซึ่งมีผลต่อการแปลภาษา เราสามารถปรับได้ตามความต้องการเรา สามารถเริ่มต้นจาก [`tsconfig-base`](https://github.com/tsconfig/bases) ได้ รายละเอียดของ Config ก็สามารถดูได้ที่ [`tsconfig.json` Refrence](https://www.typescriptlang.org/tsconfig)\n\nเวลาเขียนโค้ด TypeScript เราจะเขียนในไฟล์ที่มีนามสกุลเป็น `.ts` แทน `.js` (ถ้าเขียนเป็น JSX เราจะเขียนในไฟล์ `.tsx`)\n\nการสร้างตัวแปร ใน Typescript จะมีประกาศ type เพิ่มเข้าไป\n\n```javascript\nconst a: type = something;\n```\n\nเสร็จแล้วเมื่อจะทดสอบ ให้รัน TypeScript compiler ด้วยคำสั่งนี้\n\n```\nnpx tsc\n```\n\nตัวอย่าง\n\n```javascript\nlet a: { name: string } = {\n  name: 'John'\n}\n\na = null\n\nconsole.log(a.name)\n```\n\nถ้ามีอะไรผิดปกติ มันจะแจ้งใน Terminal หรือ Command line ของเราแบบนี้\n\n```\nexample.ts:5:1 - error TS2322: Type 'null' is not assignable to type '{ name: string; }'.\n```\n\nเมื่อแก้เสร็จแล้ว เมื่อจะรันโปรแกรมจริง ๆ จะต้องแปลงกลับมาเป็น Javascript ซึ่งทำได้โดยใช้ TypeScript compiler ด้วยคำสั่งเดียวกัน แต่เพิ่ม `--outDir` แบบนี้\n\n```\nnpx tsc --outDir ./build\n```\n\nหรือจะเพิ่ม outDir ใน `tsconfig.json`\n\n```json\n{\n  \"compilerOptions\": {\n    ...\n    \"outDir\": \"./build\"\n    ...\n  },\n}\n```\n\nแล้วรันคำสั่งเหลือแค่\n\n```\nnpx tsc\n```\n\nผลลัพธ์ที่ได้จากคำสั่งนี้ จะเป็นไฟล์ JavaScript อยู่โฟลเดอร์ตามที่กำหนดใน `outDir` ในที่นี้จะเป็น `./build`\n\n# Type ใน TypeScript\n\n## Primitive Type\n\nPrimitive Type คือ ชนิดของข้อมูลทั่วไปที่มีอยู่ใน JavaScript มีชื่อเดียวกับที่เราเห็นเมื่อใช้ Operator `typeof` มี 3 ตัวคือ\n\n- `boolean`\n- `number`\n- `string`\n\n```javascript\nconst a: boolean = true;\nconst b: number = 10;\nconst c: string = 'Hello';\n```\n\n## Object\n\nการใส่ Type ให้กับ Object เราต้องใส่เป็นรายการ Property ของ Object ลงไปแบบนี้\n\n```javascript\nconst obj: {\n  name: string\n  age: number\n  gender: string\n} = {\n  name: 'John',\n  age: 20,\n  ender: 'Male'\n};\n```\n\nเราสามารถใช้ `;` หรือ `,` คั่นได้ในกรณีเราเขียน type ของ Object บรรทัดเดียว\n\n```javascript\nconst obj: { name: string; age: number; gender: string } = {\n  name: 'John',\n  age: 20,\n  gender: 'Male'\n};\n```\n\nProperty ทุกตัวใน type นี้จะบังคับใส่ค่าหมด ถ้าใส่ไม่หมดจะมี Error ขึ้น\n\n![การแสดง Error ที่เกิดจากใส่ Property ไม่ครบ](/assets/image/post/say-hi-to-typescript/04.png)\n\nถ้ามี Property ที่ไม่อยากบังคับให้ใส่ค่าจริง ๆ เราสามารถใส่เครื่องหมาย `?` กำกับได้\n\n```javascript\nconst obj: { name: string; age?: boolean; gender: string } = {\n  name: 'John',\n  gender: 'Male'\n};\n\nif (typeof a.age === 'undefined')  { // true\n  console.log('a.age is undefined')\n}\n```\n\nเราสามารถเพิ่ม `[key: string]: type` เพื่อให้ใส่ Unknown property ได้ด้วย\n\n```javascript\nlet a: { [x: string]: string | number } = {\n  name: 'John',\n};\na['age'] = 20;\na['gender'] = 'Male';\n\nlet b: {\n  name: string\n  age: number\n  [x: string]: string | number\n} = {\n  name: 'John',\n  age: 20\n}\nb.gender = 'Male'\n```\n\nการเขียน และการใช้มีหลายแบบ\n\nแบบที่ 1\n\n```javascript\nlet a: { [x: string]: string | number } = {}\n```\n\nการใช้ type แบบนี้ Object จะรับ Property อะไรก็ได้ เวลาสร้างตัวแปร ต้องใส่ค่าของ Object เสมอ แต่แบบนี้จะใส่ เป็นค่า `{}` (Object ว่าง) ได้\n\nเวลา Assign หรือใช้ค่า Property ใน Object นั้น จะต้องใช้แบบ `obj[string index]`\n\n```javascript\na['age'] = 20;\na['gender'] = 'Male';\n```\n\nแบบที่ 2\n\n```javascript\nlet b: {\n  name: string\n  age: number\n  [x: string]: string | number\n} = {\n  name: 'John',\n  age: 20\n}\n```\n\nการประกาศแบบนี้ Object จะต้องมี `name` และ `age` เพราะฉะนั้นการสร้าง Object จะต้องใส่ค่า object ที่มี Property ให้ครบ ไม่สามารถใส่เป็น `{}` ได้ แต่จะใส่เพิ่มได้เช่นเดียวกัน เพราะใน type มี `[x: string]: string | number`\n\nและเวลา Assign หรือใช้ค่า Property ใน Object นั้น เราใช้แบบ `obj[string index]` ไม่ได้ เราจะต้องใช้แบบ `obj.name`\n\n```javascript\nb.gender = 'Male'\n```\n\nแต่เงื่อนไขของการใช้ `[key: string]: type` คือ เราต้องใส่ type ให้ครบตามจำนวน type ที่ใช้ทั้งหมดดังที่แสดงในตัวอย่างด้านบน ถ้ามี type หลายชนิด เราสามารถใช้เครื่องหมาย `|` คั่นระหว่าง type ได้ ซึ่งเครื่องหมายนี้เรียกว่า Union Type Operator ซึ่งจะอธิบายในหัวข้อต่อไป\n\nถ้าเกิดเราไม่ได้ใส่ type ให้กับ Object ใน TypeScript จะตีความว่า Object นั้นมี type `any`\n\n## Array\n\nการใส่ type ให้กับ Array ต้องใส่เป็น `type[]` เช่น `string[]` การเขียนแบบนี้สามารถใช้กับ type ทุกตัวที่กล่าวมา หากไม่อยากเขียนแบบนี้ เราสามารถเขียนอีกแบบก็ได้เหมือนกัน คือ `Array<type>`\n\n```javascript\nconst arr: string[] = ['a', 'b', 'c'];\nconst arr2: Array<string> = ['a', 'b', 'c'];\n```\n\n## `null`\n\nType ทั้งหมดที่กล่าวมาเป็น Non-nullable คือ ข้อมูลจะมีค่าเป็น null ไม่ได้ ถ้าเราต้องการให้ข้อมูลนั้นมีค่า null เราต้องใช้ type นี้ด้วย\n\n> null และ undefined ไม่เหมือนกันนะ\n> - null คือ ข้อมูลที่ถูกสร้างขึ้นมาแล้ว แต่ไม่มีค่า\n> - undefined คือ ข้อมูลที่ไม่ได้ถูกสร้างขึ้น\n\n```javascript\nlet a: null; // เก็บค่า null อย่างเดียว\nlet b: string | null; // เก็บค่า string หรือ null\n```\n\n## `any`\n\n`any` คือ Type ชนิดพิเศษที่สามารถใช้กับตัวแปรอะไรก็ได้ เมื่อใช้แล้ว TypeScript จะข้ามไม่ตรวจการใช้ตัวแปรนั้น\n\n```javascript\nconst a: any = { x: 1, y: 2 };\na.foo();\na();\na.bar = 100;\na = \"hello\";\n```\n\nตาม Best Practices `any` ถือว่าเป็น type ที่ควรหลีกเลี่ยง เพราะมันจะปิดการตรวจหมด และขณะที่โปรแกรมทำงานอาจจะเกิด Error ไม่ต่างจากการใช้ JavaScript เพียว ๆ เลย\n\n## `unknown`\n\n`unknown` เป็น type ที่ทำงานเหมือน `any` ก็คือ เป็น type ที่รองรับได้ทุกข้อมูล แต่จะพิเศษกว่า `any` คือ เราจะใช้ตัวแปรที่เป็น `unknown`  ไม่ได้เลย ถ้าไม่เช็ค type ด้วย operation `typeof` หรือ `instanceof` ก่อน หมายความว่า `unknown` ปลอดภัยกว่า `any` เราสามารถใช้ได้โดยไม่ผิดหลักอะไร\n\nส่วนมากจะใช้ `unknown` กันเมื่อไม่รู้ type ของตัวแปร หรือมีได้หลาย type และต้องเช็คด้วย `typeof` หรือ `instanceof` เช่น ตัวแปรที่เป็น Object ของ Class ต่าง ๆ\n\nคัวอย่าง:\n\n```javascript\nclass A {\n  foo() {\n    return 'foo';\n  }\n}\n\nclass B {\n  bar() {\n    return 'bar';\n  }\n}\n\n\nlet a: unknown = new A(); // ถ้าไม่ใส่ type เป็น unknown ตัวตรวจของ TypeScript จะตีความว่า `a มี type เป็น A` ทำให้ไม่สามารถ assign ค่าเป็น object ของ B ได้\n\n// ก่อนที่จะใช้ตัวแปร ต้องเช็คด้วย `instanceof` ก่อน\nif (a instanceof A) {\n  console.log(a.foo());\n}\n\na = new B();\n\nif (a instanceof B) {\n  console.log(a.bar());\n}\n\n```\n\n\n## Union Type\n\nในบางครั้ง เราอยากให้ตัวแปรสามารถเก็บค่าได้หลายชนิด เราสามารถใส่ type ที่ต้องการคั่นด้วยเครื่องหมาย `|` เช่น\n\n```javascript\nlet a: number | string;\na = 1;\na = 'hello';\n```\n\nเราใช้ค่าและฟังก์ชันต่าง ๆ ในตัวแปรที่เป็น Union ได้ถ้าค่าและฟังก์ชันต่าง ๆ ที่เราเรียกใช้มีใน Type ที่เราจับมา Union ทั้งหมด\n\n```javascript\nfunction getFirstThree(x: number[] | string) {\n  return x.slice(0, 3); // เรียกได้ไม่มี error เพราะฟังก์ชัน slice มีอยู่ในอาร์เรย์และ string\n}\n```\n\nแต่ถ้าจะเรียกค่าและฟังก์ชันที่ไม่ได้มีอยู่ทุก Type เราจะเรียกไม่ได้\n\n```javascript\nfunction printId(id: number | string) {\n  console.log(id.toUpperCase()); // เกิด error\n}\n```\n\nจากข้างบน เมื่อรันตัวแปลภาษาของ TypeScript มันจะแจ้งว่า\n\n```\nProperty 'toUpperCase' does not exist on type 'string | number'.\nProperty 'toUpperCase' does not exist on type 'number'.\n```\n\nเป็นที่แน่ชัดว่ามันเกิดจาก เราไปเรียกฟังก์ชัน `toUpperCase` ที่มีใน `string` แต่ไม่มีใน `number`\n\nวิธีแก้ไขเมื่อเกิดเหตุการณ์แบบนี้ คือ ให้เราเช็ค type ของตัวแปรด้วย `typeof` หรือ `instanceof`  ก่อนใช้ตัวแปร\n\n```javascript\nfunction printId(id: number | string) {\n  if (typeof id === \"string\") {\n    console.log(id.toUpperCase());\n  } else {\n    console.log(id);\n  }\n}\n\nprintId('one'); // ONE\nprintId(1); // 1\n```\n\nถ้าเป็นอาร์เรย์ สามารถใช้ `Array.isArray()` ได้\n\n```javascript\nconst a: number[] | string = [1, 2, 3];\nif (Array.isArray(a)) {\n  console.log(`Array joined: ${a.join(', ')}`);\n}\n```\n\n## Intersaction type\n\nเป็นการรวม type เป็นหนึ่งเดียว ทำให้เราสามารถใช้ค่าและฟังก์ชันทุกตัวของ type ที่รวมกัน\n\n```javascript\nconst a: { name: string } & { age: number } = { name: 'John', age: 30 };\n\nconsole.log(a.name); // John\nconsole.log(a.age); // 30\n```\n\n# การสร้าง Type\n\n## Type Alias\n\nถ้า type ที่ใช้มันยาวมาก และใช้บ่อย ๆ เราสามารถตั้งชื่อให้ type นั้นได้ และใช้ชื่อนั้นแทน\n\n```javascript\ntype numberOrString = number | string;\n\nconst a: numberOrString = 1;\n```\n\n```javascript\ntype Person = {\n  name: string;\n  age: number;\n};\n\nconst a: Person = {\n  name: 'John',\n  age: 30\n};\n```\n\n## Interface\n\nInterface เป็นการประกาศลักษณะของ Object\n\n```javascript\ninterface Person {\n  name: string;\n  age: number;\n}\n\n\nconst a: Person = {\n  name: 'John',\n  age: 30\n};\n```\n\nInterface และ Type Alias จะเหมือนกันทุกอย่าง แต่ที่แตกต่าง คือ การประกาศ และอีกอย่างหนึ่ง Interface จะสามารถเพิ่ม Property ขึ้นมาทีหลังได้ ในขณะที่ Type Alias ทำไม่ได้\n\n```javascript\n// การประกาศ\n// Type Alias\ntype Point = {\n  x: number;\n  y: number;\n};\n\n// Interface\ninterface Point {\n  x: number\n}\n\n// Interface สามารถประกาศซ้ำเพื่อเพิ่ม Property ได้\ninterface Point {\n  y: number\n}\n\nconst coordinate: Point = { x: 12, y: 12 }\n```\n\n# ประกาศ Type ใน Function\n\nในฟังก์ชัน ใส่ type ได้ที่ Parameter และ Return value\n\n\n```javascript\nfunction add(a: number, b: number): string {\n  return (a + b).toString();\n}\n```\n\n```javascript\nconst add = (a: number, b: number): string => (a + b).toString();\n```\n\nTypeScript ยังมี Type และรายละเอียดอื่น ๆ อีกมากมาย จนไม่สามารถเขียนได้หมด ถ้าอยากจะศึกษาเพิ่ม ก็สามารถเข้าไปที่ลิงก์ด้านล่างเพื่อศึกษาต่อได้เลยค่ะ\n\n# References & Read More\n\n- [Typescript (Wikipedia)](https://en.wikipedia.org/wiki/TypeScript)\n- [What is a tsconfig.json (Official Typescript Handbook)](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html)\n- [Everyday Types (Official Typescript Handbook)](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html)\n- [TypeScript Deep Dive](https://basarat.gitbook.io/typescript/)\n- [Learn TypeScript](https://learntypescript.dev/)\n"},{"slug":"review-course-humanistic-software-architecture","category":"posts","title":"Review Course: Humanistic Software Architecture","description":"แนะนำและบันทึกการเรียนรู้คอร์สที่ว่าด้วยการพัฒนา Software ให้ตรงใจเราและถูกใจลูกค้า","tags":["review","course","software-architecture"],"body":"\n\nปีใหม่นี้ ไอซ์มีความต้องการที่จะเรียนรู้เรื่องใหม่ ๆ เรื่อง Software Architecture ก็เป็นเรื่องหนึ่งที่ไอซ์อยากเรียนมาก เพราะอยากรู้ว่า หากเราต้องมาวางระบบการทำงานในซอฟต์แวร์ตัวหนึ่ง เราจะต้องเริ่มอย่างไร และนี่คือเหตุผลหลักที่เรียนคอร์ส Humanistic Software Architecture ของคุณคริส [Chakrit Likitkhajorn](https://www.facebook.com/chakrit.likitkhajorn) เมื่อวันที่ 4-5 เดือนกุมภาพันธ์ที่ผ่านมา\n\nโดยปกติการออกแบบ Software การเลือกสิ่งต่าง ๆ ไม่ว่าจะเป็นการเลือกภาษา เฟิร์มเวิร์ค หรือเครื่องมือต่าง ๆ ที่ใช้พัฒนา Software เราจะต้องใช้ความรู้ทางเทคนิคต่าง ๆ แต่ในคอร์สนี้ ทำให้เข้าใจว่า การใช้ความรู้ทางเทคนิคอย่างเดียวมันไม่พอ มันต้องใช้สิ่งที่เรียกว่า “ความเป็นมนุษย์” ด้วย ฟังดูแล้วอาจเป็นนามธรรม แต่สิ่งนี้กลับทำให้เราเข้าใจปัญหาต่าง ๆ ที่เกิดขึ้นได้ดีมากขึ้น โดยในคอร์สนี้ คุณคริสได้ช่วยให้ “ความเป็นมนุษย์” เป็นสิ่งที่เข้าใจง่าย สามารถใช้งานได้จริง และประยุกต์ใช้ในการออกแบบ Software ได้ด้วย\n\nสองวันนี้เรียนอะไรบ้าง ไอซ์จะบันทึกเรื่องที่เรียนและสิ่งที่ได้มาให้อ่านกัน\n\nคอร์สนี้ไม่ได้เรียนเรื่องการออกแบบระบบ Software แต่เน้นสอนให้เข้าใจหลักการคิดทางจิตวิทยาเพื่อเข้าใจปัญหาก่อนที่จะออกแบบ และพัฒนาสิ่งต่าง ๆ ตอร์สนี้เหมาะสำหรับคนที่มีประสบการณ์การเขียนโปรแกรมระดับหนึ่ง มีความรู้เรื่องการใช้ภาษา หรือเครื่องมือต่าง ๆ มากกว่า 1 ตัว และอยู่ในจุดที่ต้องเลือกสิ่งต่าง ๆ ที่ใช้พัฒนาระบบให้กับบริษัท\n\n# First Day\n\nวันแรก จะเรียนเรื่องโครงสร้างของสิ่งที่เรียกว่า “ปัญหา” เราจะได้รู้ว่า “ปัญหา” นั้นไม่ใช่แค่ “ฉันหิว” “ฉันจน” แต่เป็นคำถามที่ว่า “ทำอย่างไรฉันจะอิ่ม?” “ทำอย่างไรฉันจะรวย?” และเราจะหาคำตอบของคำถามแบบนี้ได้โดยใช้ “Satir” ซึ่งเป็นวิธีบำบัดทางจิตวิทยาที่นำไปสู่ความเข้าใจความปรารถนาที่แท้จริง (Yearning) ของตัวเองและคนอื่น เมื่อมีความเข้าใจ ก็จะทำให้เกิดความพึงพอใจ และเมื่อมีความพึงพอใจ ปัญหาต่าง ๆ ก็จะจบลงได้ไม่ยาก\n\nPoint ของเรื่องนี้ก็คือ\n\n1. มนุษย์ทุกคนมีความสามารถในการอยู่กับอุปสรรคในชีวิตเสมอ ไม่ว่าจะอยู่ได้ด้วยมุมมองการคิดอย่างไร\n2. เราทุกคนมีศักยภาพในการเข้าใจความปรารถนาเบื้องลึกของกันและกันได้ เหมือนที่เราเข้าใจความต้องการของเด็กทารกที่ยังพูดไม่ได้\n\nเราทุกคนมีศักยภาพทั้งสองข้อในตัวอยู่แล้ว และใช้มันเพื่อรับมือปัญหาที่เกิดขึ้นในชีวิต ซึ่งเราจะใช้มันได้ดีเมื่อเราเข้าใจความปรารถนาที่แท้จริงของตัวเอง ถ้าเราไม่เข้าใจ เราก็จะไม่ได้ตอบสนองความปรารถนาอย่างเพียงพอ ถึงแม้มันจะมีเสียงดังมากในหัวเราก็ตาม และเมื่อเราไม่ได้ทำความเข้าใจความปรารถนาของตัวเองที่เกิดเสียงดังขึ้นมา ก็จะเป็นไปได้ยากที่จะเข้าใจความปรารถนาของคนอื่น เมื่อเกิดปัญหาขึ้นมา ก็จะแก้ปัญหาได้ไม่ตรงกับใจเท่าไหร่ แม้แก้ปัญหาไปจนจบ ความพึงพอใจก็ไม่เกิดขึ้น แถมเกิดปัญหาใหม่ให้แก้เรื่อย ๆ อีกไม่รู้จบ\n\n```\n💬 ตัวอย่าง: ลูกค้าขอให้เราทำ Feature หนึ่งในโปรเจคหนึ่ง\nลูกค้า: ผมให้คุณทำ Feature AAA มันมีหน้าตาแบบนี้ ๆๆๆๆ ทำงานตามนั้น ๆๆๆๆ นะ\nDev ก: โอ้ว โอเค ได้เลย เดี๋ยวจัดให้ภายในหนึ่งอาทิตย์\nDev ก ก็ทำ Feature AAA ตรงตามที่ลูกค้าพูดเป๊ะๆ\n…หนึ่งอาทิตย์ต่อมา…\nDev ก: อ่า ทำให้ละ Feature AAA ตามที่คุณขอ\nลูกค้า: มันไม่ใช่นะคุณ มันต้องแบบนี้ ๆๆๆๆ ต่างหาก\nDev ก:  อ้าว คุณเคยบอกว่ามันเป็นแบบนี้ ๆๆๆ ไม่ใช่เหรอ\nลูกค้า: เราต้องการแบบนี้ ๆๆๆๆ ต่างหาก\nDev ก: โอเค… (ในใจเต็มไปด้วยความงงปนหงุดหงิด อะไรกันเนี่ยยยย!!!??)\nสุดท้าย Dev ก ก็ต้องเสียเวลาแก้ Feature AAA ตามที่ลูกค้าต้องการจริง ๆ\n```\n\nเพราะฉะนั้น การที่จะแก้ปัญหาได้ดีมากขึ้น อย่างแรก เราต้องให้เวลาในการฟังเสียงตัวเอง เพื่อที่จะเข้าใจตัวตนและความปรารถนาที่แท้จริงของตัวเราก่อน\n\nในคอร์สนี้ ก็ได้มี Workshop ให้เรายกตัวอย่างปัญหาที่เราเจอ เช่น เมื่อเราต้องไปเปลี่ยน Logic ในโค้ดที่ยุ่งเหยิง จากนั้นให้เราลองสำรวจตัวตนที่แท้จริงของตัวเรา จากปัญหาที่เราตั้งผ่าน Satir Iceberg model หลังจากนั้น เราก็จะได้รู้ว่า จากปัญหาที่เราตั้ง เรามีพฤติกรรมต่อเรื่องนี้อย่างไร และภายใต้การกระทำนั้น เราได้มีความรู้สึก แนวคิด ความคาดหวัง ความต้องการในเบื้องลึกของจิตใจอะไรเป็นแรงผลักดัน สิ่งเหล่านี้บ่งบอกถึงตัวตนของตัวเรา\n\nเมื่อเราเข้าใจตัวเองแล้ว ต่อไป เราจะต้องทำใจเปิดรับเข้าไว้ เพื่อที่จะทำความเข้าใจและสัมผัสได้ถึงความคาดหวังและความปรารถนาของคนที่เกี่ยวข้องกับปัญหา สุดท้าย เมื่อเข้าใจความปรารถนาลึก ๆ ในตัวเราและคนอื่น เราก็จะสามารถหาจุดตรงกลางระหว่างความต้องการของเราและคนนั้น ในที่สุดแล้วจะได้ Solution ที่ทำให้ทุกคนพึงพอใจได้\n\nถ้าเราทำได้ ก็ถือว่าเราได้ใช้ศักยภาพที่ว่าไปแล้ว\n\nต่อจากนั้น ก็มีเรียนรู้เรื่อง “3 Centre of Intelligence” เป็นวิธีหนึ่งที่อธิบายพฤติกรรมของคนเราและสามารถนำไปใช้แก้ปัญหาต่าง ๆ ได้ โดยการแบ่งเป็น 3 ส่วนเปรียบเทียบกับภาพร่างกายมนุษย์คือ Head (หัว แทนความคิด เหตุผล), Heart (หัวใจ แทนความรู้สึกจิตใจ), Body (ร่างกาย แทนการกระทำ สัญชาติญาณ) วิธีนี้จะบอกได้ว่าเวลาเกิดเหตุการณ์หนึ่งหรือมีปัญหาที่ต้องแก้ คนหนึ่งจะใช้ส่วนไหนเป็นหลัก และในสถานการณ์ต่าง ๆ เราควรใช้ส่วนไหนบ้าง\n\nเราสามารถประยุกต์ใช้ตอนนำเสนอเครื่องมือ หรือไอเดียใหม่ ๆ ให้กับทีม ถ้าเราใช้มันเป็น จะทำให้คนในทีมเข้าใจและซื้อไอเดียที่เรานำเสนอมากขึ้น ในคลาสก็มีให้ฝึกนำเสนอโดยใช้หลักการนี้ด้วย\n\n# Second Day\n\nวันนี้มีเรียนเรื่องของการ Apply ความรู้ต่าง ๆ ที่เรียนในวันแรกเข้ากับ “Abstraction” ซี่งหมายถึง การทำให้สิ่งหนึ่งที่มีรายละเอียดมากมายให้ดูง่ายขึ้น โดยตัดสิ่งที่ไม่จำเป็นออกให้กลายเป็นก้อนกลม ๆ ที่ดูแวบเดียวก็รู้ว่ามันคืออะไร ส่วนมากในวงการ Software จะใช้คำนี้กันมาก มีใช้คำนี้กับเรื่องของการ Design เป็นภาพต่าง ๆ เช่น แผนภาพที่แสดงโครงสร้าง การเชื่อมต่อ Flow การทำงาน UX/UI เป็นต้น การ Clean Data รวมถึงการ Refactor โค้ดโปรแกรม\n\nจากเรื่องนี้เราก็ได้เรียนรู้ว่า การที่จะทำ Abstraction ได้อย่างถูกต้อง เราจะต้องยึดจากภาพสำเร็จที่เราตั้งไว้ ซึ่งภาพสำเร็จสามารถทำขึ้นมาได้โดยสร้างภาพ “ปัญหา” และใช้ความรู้ที่เรียนรู้ในวันที่ 1 เพื่อแตกปัญหาจนหา Solution สุดท้ายได้นี่เอง ในคลาส คุณคริสก็ได้ยกตัวอย่างจากประสบการณ์ เกี่ยวกับผลที่ได้ถ้าเวลาเรา Abstract ไม่ได้ยึดติดกับภาพสำเร็จ แต่ไปยึดติดกับอย่างอื่น เช่น Discomfort, Fear, Happiness มันจะเกิดผลอย่างไร พร้อมทั้งแนะนำการ Abstract ที่ถูกต้องและคุ้มกับเวลาที่เสียไป\n\nจะเห็นว่า วันที่สอง จะเน้นเรียนการประยุกต์ใช้ในเรื่องของการออกแบบโครงสร้างและแก้ปัญหาต่าง ๆ ที่เกี่ยวกับ Software\n\n# หลังจากผ่านไป 1 เดือน\n\nหลังจากเรียนเสร็จ ไอซ์ก็ทำความเข้าใจและพยายามนำไปใช้ในชีวิตจริง ที่ผ่านมา ไอซ์ก็ได้เจอโจทย์ปัญหามากมาย ทั้งในการทำงาน และชีวิตส่วนตัว  ในช่วงที่เขียนโพสอยู่นี้ ก็อยู่ในช่วงที่ต้องรับผิดชอบการ Improve Product และ Refactor โค้ดอยู่พอดี และทางด้านชีวิตส่วนตัว ไอซ์กำลังวางแผนพัฒนาตัวเอง และมีเพื่อนปรึกษาปัญหา และการทำงานพอสมควร เมื่อไอซ์ได้ใช้สิ่งที่เรียนมา ผลลัพธ์ที่ได้รับมีหลายข้อเลยทีเดียว\n\n1. ใจเย็น มีสติในการคิด ตัดสินใจเรื่องต่าง ๆ มากขึ้น\n2. รู้จักตัวเอง และความต้องการของตัวเองมากขึ้น\n3. วางแผนตีโจทย์ปัญหาหาวิธีแก้ได้ดีขึ้น มองเห็นเป้าหมายของมันชัดเจน\n4. เข้าใจความต้องการของคนที่เกี่ยวข้องกับปัญหา ทำให้ให้คำปรึกษา และแก้ปัญหาให้พวกเขาได้ดีขึ้น และพวกเขาก็พอใจ\n5. สุขภาพจิตดีขึ้น ความเครียดน้อยลง เพราะเกิดความพึงพอใจที่ปัญหาได้รับการแก้ไข\n\n# สรุปทิ้งท้าย\n\nคอร์สนี้ไม่ได้สอนแค่ว่าทำอย่างไรถึงจะออกแบบ Architecture ของ Software ที่ดีที่สุดออกมา ยังมีสอนการแก้ปัญหาต่าง ๆ ที่เกิดขึ้นอย่างมีประสิทธิภาพ หลังจากเรียนคอร์สนี้ เราก็ได้รู้ว่า ปัญหาส่วนใหญ่เกิดจากความต้องการของมนุษย์ที่แตกต่างกัน เราสามารถใช้หลักการทางจิตวิทยามาช่วย เพื่อที่ทำให้เราสามารถเข้าใจความต้องการที่แท้จริง นำมาสู่ความพึงพอใจและปัญหาก็ได้รับการแก้ไข หลักการเหล่านี้สามารถใช้ในชีวิตประจำวัน และการทำงานทั่วไปได้\n\nตุณคริส เจ้าของคอร์สมี Plan ที่จะเปิดรอบสอนคอร์สนี้ได้เพิ่มเติม ใครที่สนใจอยากเรียนรู้เพิ่มเติม สามารถติดตามได้ที่เฟซบุ๊คของคุณคริส [Chakrit Likitkhajorn](https://www.facebook.com/chakrit.likitkhajorn)\n\n# Review เพิ่มเติมจากบล็อกอื่น\n\n- [บันทึกการเรียน Humanistic Software Architecture ของคุณ Ping](https://naiwaen.debuggingsoft.com/2023/03/%e0%b8%9a%e0%b8%b1%e0%b8%99%e0%b8%97%e0%b8%b6%e0%b8%81-humanistic-software-architecture/)\n- [บันทึกการเรียน Humanistic Software Architecture ของคุณ Sarunyhot](https://sarunyhot.medium.com/%E0%B8%9A%E0%B8%B1%E0%B8%99%E0%B8%97%E0%B8%B6%E0%B8%81%E0%B8%81%E0%B8%B2%E0%B8%A3%E0%B9%80%E0%B8%A3%E0%B8%B5%E0%B8%A2%E0%B8%99-humanistic-architecture-5a47b0b488e5)\n"}]